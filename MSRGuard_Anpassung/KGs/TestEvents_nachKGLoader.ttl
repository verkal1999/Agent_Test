@prefix ag: <http://www.semanticweb.org/AgentProgramParams/> .
@prefix dp: <http://www.semanticweb.org/AgentProgramParams/dp_> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ag: a owl:Ontology .

ag:GVLList_GVL a ag:class_GlobalVariableList ;
    dp:hasGlobalVariableListName "GVL" ;
    ag:op_listsGlobalVariable ag:GVL__dot__DiagnoseRequested,
        ag:GVL__dot__Fehler,
        ag:GVL__dot__NotStopp,
        ag:GVL__dot__Start,
        ag:GVL__dot__Stopp,
        ag:GVL__dot__Weiter .

ag:GVLList_OPCUA a ag:class_GlobalVariableList ;
    dp:hasGlobalVariableListName "OPCUA" ;
    ag:op_listsGlobalVariable ag:OPCUA__dot__Alt_abort,
        ag:OPCUA__dot__Alt_found,
        ag:OPCUA__dot__DiagnoseFinished,
        ag:OPCUA__dot__LastGEMMAStateBeforeFailure,
        ag:OPCUA__dot__M1,
        ag:OPCUA__dot__M2,
        ag:OPCUA__dot__M3,
        ag:OPCUA__dot__TriggerD1,
        ag:OPCUA__dot__TriggerD2,
        ag:OPCUA__dot__TriggerD3,
        ag:OPCUA__dot__Z1,
        ag:OPCUA__dot__Z2,
        ag:OPCUA__dot__Z3,
        ag:OPCUA__dot__bool1,
        ag:OPCUA__dot__bool2,
        ag:OPCUA__dot__bool3,
        ag:OPCUA__dot__lastExecutedProcess,
        ag:OPCUA__dot__lastExecutedSkill .

ag:PLCProject__Proj1 a ag:class_PLCProject ;
    dp:hasPLCProjectName "Proj1" ;
    ag:op_consistsOfPOU ag:FBType_FB_Automatikbetrieb_F1,
        ag:FBType_FB_Betriebsarten,
        ag:FBType_FB_Diagnose_D2,
        ag:FBType_FB_InitFahrt_A6_A2,
        ag:FBType_FB_Methode1Job,
        ag:FBType_FB_Notaus_D1,
        ag:FBType_FB_ProduktionMitStoerung_D3,
        ag:Program_MAIN .

ag:StandardFBType_CTD a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "CTD" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_CTD_CD,
        ag:Port_CTD_CV,
        ag:Port_CTD_LD,
        ag:Port_CTD_PV,
        ag:Port_CTD_Q ;
    rdfs:comment "CTD ist ein Abwärtszähler. LD lädt CV mit dem Preset Wert PV. Jede steigende Flanke an CD verringert CV um 1 bis minimal 0. Q wird TRUE, wenn CV gleich 0 ist."@de .

ag:StandardFBType_CTU a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "CTU" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_CTU_CU,
        ag:Port_CTU_CV,
        ag:Port_CTU_PV,
        ag:Port_CTU_Q,
        ag:Port_CTU_R ;
    rdfs:comment "CTU ist ein Aufwärtszähler. Jede steigende Flanke an CU erhöht CV um 1. R setzt CV auf 0 zurück. Q wird TRUE, sobald CV den Preset Wert PV erreicht oder überschreitet."@de .

ag:StandardFBType_CTUD a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "CTUD" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_CTUD_CD,
        ag:Port_CTUD_CU,
        ag:Port_CTUD_CV,
        ag:Port_CTUD_LD,
        ag:Port_CTUD_PV,
        ag:Port_CTUD_QD,
        ag:Port_CTUD_QU,
        ag:Port_CTUD_R ;
    rdfs:comment "CTUD ist ein Auf und Abwärtszähler. Steigende Flanken an CU erhöhen CV, steigende Flanken an CD verringern CV. R setzt CV auf 0. LD lädt CV mit PV. QU wird TRUE, wenn CV größer gleich PV ist. QD wird TRUE, wenn CV gleich 0 ist."@de .

ag:StandardFBType_F_TRIG a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "F_TRIG" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_F_TRIG_CLK,
        ag:Port_F_TRIG_Q ;
    rdfs:comment "F_TRIG erkennt eine fallende Flanke an CLK. Q wird genau für einen Programmscan TRUE, wenn CLK von TRUE auf FALSE wechselt. Damit lassen sich Abschalt Ereignisse als Impuls weiterverarbeiten."@de .

ag:StandardFBType_SR a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "SR" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_SR_Q1,
        ag:Port_SR_R,
        ag:Port_SR_S1 ;
    rdfs:comment "SR ist ein bistabiles Speicherglied mit Set Priorität. S1 setzt den gespeicherten Zustand auf TRUE. R setzt ihn auf FALSE. Wenn S1 und R gleichzeitig TRUE sind, dominiert Set und Q1 bleibt TRUE."@de .

ag:StandardFBType_TOF a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "TOF" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_TOF_ET,
        ag:Port_TOF_IN,
        ag:Port_TOF_PT,
        ag:Port_TOF_Q ;
    rdfs:comment "TOF ist eine Ausschaltverzögerung. Solange IN TRUE ist, ist Q TRUE. Wenn IN von TRUE auf FALSE wechselt, bleibt Q noch für die Dauer PT TRUE und ET zählt die Nachlaufzeit. Wenn IN während des Nachlaufs wieder TRUE wird, wird der Nachlauf abgebrochen und Q bleibt TRUE."@de .

ag:class_CustomFBType a owl:Class ;
    rdfs:comment "Diese Klasse kennzeichnet Function Block Typen, die projekt spezifisch implementiert wurden und nicht aus einer Standardbibliothek stammen. Sie dient dazu, benutzerdefinierte Logikbausteine semantisch von generischen Standardfunktionen zu trennen, damit Analysen gezielter durchgeführt werden können. CustomFBTypes bilden häufig die eigentlichen Skills oder spezifische Steuerungslogik ab, zum Beispiel Bewegungen einer Achse, Prozessschritte oder die Abbildung einer Stationsfunktion. Im Knowledge Graph ist die Klasse hilfreich, um Abhängigkeiten zwischen Skills zu identifizieren, Schnittstellen zu vergleichen und zentrale Bausteine zu priorisieren. Aus PLCopen XML lassen sich solche Typen meist daran erkennen, dass sie als eigene POU Definitionen im Projekt auftauchen und keinen eindeutigen Standardnamen wie TON, TOF oder RS besitzen. In späteren Auswertungen kann diese Unterscheidung genutzt werden, um automatisiert eine Liste relevanter Skills zu extrahieren und Standardkomponenten wie Timer oder Trigger auszublenden. Insgesamt unterstützt class_CustomFBType somit die fachliche Strukturierung der Projektlogik und erleichtert die Dokumentation, weil projektbezogene Funktionen klar markiert werden."@de ;
    rdfs:subClassOf ag:class_FBType .

dp:hasConfidence a owl:DatatypeProperty ;
    rdfs:subPropertyOf dp:hasHypothesisParams .

dp:hasConsistencyReport a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasDefaultPortValue a owl:DatatypeProperty ;
    rdfs:domain ag:class_Port ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPortAttribute .

dp:hasDefaultVariableValue a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasVariableAttribute .

dp:hasDescription a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:string .

dp:hasEvidenceSnippet a owl:DatatypeProperty ;
    rdfs:subPropertyOf dp:hasHypothesisParams .

dp:hasExpressionText a owl:DatatypeProperty ;
    rdfs:domain ag:class_Expression ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasSignalSourceAttribute .

dp:hasGlobalVariableListName a owl:DatatypeProperty ;
    rdfs:domain ag:class_GlobalVariableList ;
    rdfs:range xsd:string .

dp:hasHardwareAddress a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf owl:topDataProperty .

dp:hasOPCUADataAccess a owl:DatatypeProperty ;
    rdfs:domain ag:class_SignalSource ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:hasSignalSourceAttribute .

dp:hasOPCUAWriteAccess a owl:DatatypeProperty ;
    rdfs:domain ag:class_SignalSource ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:hasSignalSourceAttribute .

dp:hasPLCProjectName a owl:DatatypeProperty ;
    rdfs:domain ag:class_PLCProject ;
    rdfs:range xsd:string .

dp:hasPOUCode a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasPOUCodeDescription a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasPOUDeclarationHeader a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasPOULanguage a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasPOUName a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasPOUType a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:hasPortDirection a owl:DatatypeProperty ;
    rdfs:domain ag:class_Port ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPortAttribute .

dp:hasPortName a owl:DatatypeProperty ;
    rdfs:domain ag:class_Port ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPortAttribute .

dp:hasPortType a owl:DatatypeProperty ;
    rdfs:domain ag:class_Port ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasPortAttribute .

dp:hasRationale a owl:DatatypeProperty ;
    rdfs:subPropertyOf dp:hasHypothesisParams .

dp:hasSkillDescription a owl:DatatypeProperty ;
    rdfs:domain ag:class_Skill ;
    rdfs:range xsd:string .

dp:hasVariableName a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasVariableAttribute .

dp:hasVariableScope a owl:DatatypeProperty ;
    rdfs:range [ a rdfs:Datatype ;
            owl:oneOf [ a rdf:List ;
                    rdf:first "global" ;
                    rdf:rest [ a rdf:List ;
                            rdf:first "input" ;
                            rdf:rest [ a rdf:List ;
                                    rdf:first "local" ;
                                    rdf:rest [ a rdf:List ;
                                            rdf:first "output" ;
                                            rdf:rest () ] ] ] ] ] ;
    rdfs:subPropertyOf dp:hasVariableAttribute .

dp:hasVariableType a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:string ;
    rdfs:subPropertyOf dp:hasVariableAttribute .

dp:inferredAt a owl:DatatypeProperty ;
    rdfs:subPropertyOf dp:hasHypothesisParams .

dp:inferredByModel a owl:DatatypeProperty ;
    rdfs:subPropertyOf dp:hasHypothesisParams .

dp:ioRawXml a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:string .

dp:isGEMMAOutputLayer a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:isSpecificLayer .

dp:isGEMMAStateMachine a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:isSpecificLayer .

dp:isUnusedPort a owl:DatatypeProperty ;
    rdfs:domain ag:class_Port ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:isUnused .

dp:isUnusedVar a owl:DatatypeProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:isUnused .

ag:op_assignsFrom a owl:ObjectProperty ;
    rdfs:comment "# 2. Woher kommt das Signal? Hier ist die Signal-Quelle bei Funktionsaufruf" ;
    rdfs:domain ag:class_ParameterAssignment ;
    rdfs:range ag:class_SignalSource .

ag:op_assignsToPort a owl:ObjectProperty ;
    rdfs:comment "# 1. Wohin geht das Signal? (Zum Port \"CLK\" definiert im Typ R_TRIG)" ;
    rdfs:domain ag:class_ParameterAssignment ;
    rdfs:range ag:class_Port .

ag:op_callsPOU a owl:ObjectProperty ;
    rdfs:domain ag:class_POUCall ;
    rdfs:range ag:class_POU .

ag:op_consistsOfPOU a owl:ObjectProperty ;
    rdfs:domain ag:class_PLCProject ;
    rdfs:range ag:class_POU .

ag:op_containsPOUCall a owl:ObjectProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range ag:class_POUCall .

ag:op_hasAssignment a owl:ObjectProperty ;
    rdfs:domain ag:class_POUCall ;
    rdfs:range ag:class_ParameterAssignment .

ag:op_hasCallerVariable a owl:ObjectProperty ;
    rdfs:domain ag:class_POUCall ;
    rdfs:range ag:class_Variable .

ag:op_hasHypothesisAboutPOU a owl:ObjectProperty ;
    rdfs:domain ag:class_SkillImplementationHypothesis ;
    rdfs:range ag:class_POU ;
    rdfs:subPropertyOf ag:op_HypothesisConnections .

ag:op_hasHypothesisAboutSkill a owl:ObjectProperty ;
    rdfs:domain ag:class_SkillImplementationHypothesis ;
    rdfs:range ag:class_Skill ;
    rdfs:subPropertyOf ag:op_HypothesisConnections .

ag:op_hasInfluenceOnVariable a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_Variable .

ag:op_hasInternalVariable a owl:ObjectProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range ag:class_Variable .

ag:op_hasPort a owl:ObjectProperty ;
    rdfs:domain ag:class_FBType ;
    rdfs:range ag:class_Port .

ag:op_implementsPort a owl:ObjectProperty ;
    rdfs:comment "Verbindet eine interne Variable eines FBs mit dem Port, den sie repräsentiert" ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_Port .

ag:op_implementsSkill a owl:ObjectProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range ag:class_Skill .

ag:op_instantiatesPort a owl:ObjectProperty ;
    rdfs:domain ag:class_PortInstance ;
    rdfs:range ag:class_Port .

ag:op_isBoundToChannel a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_IOChannel .

ag:op_isBoundToPort a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_Port .

ag:op_isExpressionCreatedBy a owl:ObjectProperty ;
    rdfs:domain ag:class_Expression ;
    rdfs:range ag:class_SignalSource .

ag:op_isInstanceOfFBType a owl:ObjectProperty ;
    rdfs:domain ag:class_FBInstance ;
    rdfs:range ag:class_FBType .

ag:op_isInstanceOfPort a owl:ObjectProperty ;
    rdfs:domain ag:class_PortInstance ;
    rdfs:range ag:class_Port .

ag:op_isMappedToPOU a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_POU .

ag:op_isMappedToVariable a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_Variable .

ag:op_isPortOfInstance a owl:ObjectProperty ;
    rdfs:domain ag:class_PortInstance ;
    rdfs:range ag:class_FBInstance .

ag:op_isSubProgramOf a owl:ObjectProperty ;
    rdfs:domain ag:class_Program ;
    rdfs:range ag:class_Program .

ag:op_listsGlobalVariable a owl:ObjectProperty ;
    rdfs:domain ag:class_GlobalVariableList ;
    rdfs:range ag:class_Variable .

ag:op_representsFBInstance a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_FBInstance .

ag:op_usesLiteral a owl:ObjectProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range ag:class_SourceLiteral .

ag:op_usesPort a owl:ObjectProperty ;
    rdfs:domain ag:class_Variable ;
    rdfs:range ag:class_Port .

ag:op_usesVariable a owl:ObjectProperty ;
    rdfs:domain ag:class_POU ;
    rdfs:range ag:class_Variable .

ag:FBInst_FB_Automatikbetrieb_F1_pPer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TP .

ag:FBInst_FB_Automatikbetrieb_F1_rPer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Automatikbetrieb_F1_rStart a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Automatikbetrieb_F1_rStep1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Automatikbetrieb_F1_rtStoer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Automatikbetrieb_F1_tPer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_Automatikbetrieb_F1_tSchritt1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_Automatikbetrieb_F1_tSchritt2 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_Betriebsarten_RS_A1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_A2 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_A5 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_A6 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_AutomaticOperationMode a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_CycleEnded a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_D1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_D2 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_D3 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_F1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_InitialDrive a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_InitialState a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_RS_ManualOperationMode a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_RS .

ag:FBInst_FB_Betriebsarten_R_TRIG_Automatic a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Betriebsarten_R_TRIG_CycleEnded a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Betriebsarten_R_TRIG_Init a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Betriebsarten_R_TRIG_InitialDrive a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Betriebsarten_R_TRIG_Manual a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Diagnose_D2_rtAck a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Diagnose_D2_rtD3 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Diagnose_D2_rtFinished a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Diagnose_D2_rtReq a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_Diagnose_D2_tpPulse a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TP .

ag:FBInst_FB_InitFahrt_A6_A2_tInit a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_Methode1Job_t20s a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_Notaus_D1_ton5s a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_ProduktionMitStoerung_D3_pPer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TP .

ag:FBInst_FB_ProduktionMitStoerung_D3_rPer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_ProduktionMitStoerung_D3_rStart a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_ProduktionMitStoerung_D3_rStep1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_ProduktionMitStoerung_D3_rtStoer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_FB_ProduktionMitStoerung_D3_tPer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_ProduktionMitStoerung_D3_tSchritt3 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_FB_ProduktionMitStoerung_D3_tSchritt4 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_TON .

ag:FBInst_MAIN_edgeDone a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_MAIN_edgeF1 a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:StandardFBType_R_TRIG .

ag:FBInst_MAIN_fbAuto a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_Automatikbetrieb_F1 .

ag:FBInst_MAIN_fbBA a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_Betriebsarten .

ag:FBInst_MAIN_fbDiag a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_Diagnose_D2 .

ag:FBInst_MAIN_fbInit a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_InitFahrt_A6_A2 .

ag:FBInst_MAIN_fbJob a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_Methode1Job .

ag:FBInst_MAIN_fbNot a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_Notaus_D1 .

ag:FBInst_MAIN_fbProStoer a ag:class_FBInstance ;
    ag:op_isInstanceOfFBType ag:FBType_FB_ProduktionMitStoerung_D3 .

ag:GVL__dot__DiagnoseRequested a ag:class_Variable ;
    dp:hasVariableName "DiagnoseRequested",
        "GVL.DiagnoseRequested" ;
    dp:hasVariableType "BOOL" .

ag:GVL__dot__Fehler a ag:class_Variable ;
    dp:hasVariableName "Fehler",
        "GVL.Fehler" ;
    dp:hasVariableScope "global" ;
    dp:hasVariableType "BOOL" ;
    ag:op_isBoundToPort ag:Port_FB_Betriebsarten_Fehler .

ag:GVL__dot__NotStopp a ag:class_Variable ;
    dp:hasInitialValue "TRUE" ;
    dp:hasVariableName "GVL.NotStopp",
        "NotStopp" ;
    dp:hasVariableType "BOOL" .

ag:GVL__dot__Start a ag:class_Variable ;
    dp:hasVariableName "GVL.Start",
        "Start" ;
    dp:hasVariableScope "global" ;
    dp:hasVariableType "BOOL" ;
    ag:op_isBoundToPort ag:Port_FB_Betriebsarten_Start .

ag:GVL__dot__Stopp a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasVariableName "GVL.Stopp",
        "Stopp" ;
    dp:hasVariableType "BOOL" .

ag:GVL__dot__Weiter a ag:class_Variable ;
    dp:hasVariableName "GVL.Weiter",
        "Weiter" ;
    dp:hasVariableScope "global" ;
    dp:hasVariableType "BOOL" ;
    ag:op_isBoundToPort ag:Port_FB_Betriebsarten_Weiter .

ag:OPCUA__dot__Alt_abort a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "Alt_abort",
        "OPCUA.Alt_abort" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__Alt_found a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "Alt_found",
        "OPCUA.Alt_found" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__DiagnoseFinished a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "DiagnoseFinished",
        "OPCUA.DiagnoseFinished" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__LastGEMMAStateBeforeFailure a ag:class_Variable ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "LastGEMMAStateBeforeFailure",
        "OPCUA.LastGEMMAStateBeforeFailure" ;
    dp:hasVariableType "STRING" .

ag:OPCUA__dot__M1 a ag:class_Variable ;
    dp:hasInitialValue "0" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "M1",
        "OPCUA.M1" ;
    dp:hasVariableType "INT" .

ag:OPCUA__dot__M2 a ag:class_Variable ;
    dp:hasInitialValue "0" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "M2",
        "OPCUA.M2" ;
    dp:hasVariableType "INT" .

ag:OPCUA__dot__M3 a ag:class_Variable ;
    dp:hasInitialValue "0" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "M3",
        "OPCUA.M3" ;
    dp:hasVariableType "INT" .

ag:OPCUA__dot__TriggerD1 a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.TriggerD1",
        "TriggerD1" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__TriggerD2 a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.TriggerD2",
        "TriggerD2" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__TriggerD3 a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.TriggerD3",
        "TriggerD3" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__Z1 a ag:class_Variable ;
    dp:hasInitialValue "0" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.Z1",
        "Z1" ;
    dp:hasVariableType "INT" .

ag:OPCUA__dot__Z2 a ag:class_Variable ;
    dp:hasInitialValue "0" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.Z2",
        "Z2" ;
    dp:hasVariableType "INT" .

ag:OPCUA__dot__Z3 a ag:class_Variable ;
    dp:hasInitialValue "0" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.Z3",
        "Z3" ;
    dp:hasVariableType "INT" .

ag:OPCUA__dot__bool1 a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.bool1",
        "bool1" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__bool2 a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.bool2",
        "bool2" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__bool3 a ag:class_Variable ;
    dp:hasInitialValue "FALSE" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.bool3",
        "bool3" ;
    dp:hasVariableType "BOOL" .

ag:OPCUA__dot__lastExecutedProcess a ag:class_Variable ;
    dp:hasInitialValue "''" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.lastExecutedProcess",
        "lastExecutedProcess" ;
    dp:hasVariableType "STRING" .

ag:OPCUA__dot__lastExecutedSkill a ag:class_Variable ;
    dp:hasInitialValue "''" ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "OPCUA.lastExecutedSkill",
        "lastExecutedSkill" ;
    dp:hasVariableType "STRING" .

ag:Port_CTD_CD a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "CD" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "CD ist der Zähleingang zum Herunterzählen. Jede steigende Flanke verringert CV."@de .

ag:Port_CTD_CV a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "CV" ;
    dp:hasPortType "INT" ;
    rdfs:comment "CV ist der aktuelle Countdown Wert und zeigt die verbleibende Anzahl."@de .

ag:Port_CTD_LD a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "LD" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "LD lädt den Preset Wert PV in CV und initialisiert damit den Countdown."@de .

ag:Port_CTD_PV a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PV" ;
    dp:hasPortType "INT" ;
    rdfs:comment "PV ist der Preset Wert und typische Startwert für den Countdown."@de .

ag:Port_CTD_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q wird TRUE, wenn CV gleich 0 ist und der Countdown beendet ist."@de .

ag:Port_CTUD_CD a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "CD" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "CD ist der Zähleingang zum Herunterzählen. Jede steigende Flanke verringert CV."@de .

ag:Port_CTUD_CU a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "CU" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "CU ist der Zähleingang zum Hochzählen. Jede steigende Flanke erhöht CV."@de .

ag:Port_CTUD_CV a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "CV" ;
    dp:hasPortType "INT" ;
    rdfs:comment "CV ist der aktuelle Zählerstand und wird oft für Füllstände oder Stückzahlen genutzt."@de .

ag:Port_CTUD_LD a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "LD" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "LD lädt PV in CV und setzt damit einen definierten Startstand."@de .

ag:Port_CTUD_PV a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PV" ;
    dp:hasPortType "INT" ;
    rdfs:comment "PV ist der Preset Wert. QU wird TRUE, wenn CV größer gleich PV ist."@de .

ag:Port_CTUD_QD a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "QD" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "QD ist die Meldung für unteren Grenzwert. QD wird TRUE, wenn CV gleich 0 ist."@de .

ag:Port_CTUD_QU a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "QU" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "QU ist die Meldung für oberen Grenzwert. QU wird TRUE, wenn CV größer gleich PV ist."@de .

ag:Port_CTUD_R a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "R" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "R setzt CV auf 0 zurück."@de .

ag:Port_CTU_CU a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "CU" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "CU ist der Zähleingang. Jede steigende Flanke erhöht den Zählerstand CV."@de .

ag:Port_CTU_CV a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "CV" ;
    dp:hasPortType "INT" ;
    rdfs:comment "CV ist der aktuelle Zählerstand. Wird häufig angezeigt oder geloggt."@de .

ag:Port_CTU_PV a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PV" ;
    dp:hasPortType "INT" ;
    rdfs:comment "PV ist der Preset Wert. Sobald CV größer gleich PV ist, wird Q TRUE."@de .

ag:Port_CTU_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q ist die Grenzwertmeldung. Q wird TRUE, wenn CV den Preset Wert erreicht oder überschreitet."@de .

ag:Port_CTU_R a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "R" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "R setzt den Zählerstand CV auf 0 zurück."@de .

ag:Port_F_TRIG_CLK a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "CLK" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "CLK ist der BOOL Eingang, der überwacht wird. Bei einer fallenden Flanke wird Q erzeugt."@de .

ag:Port_F_TRIG_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q ist ein BOOL Impuls für einen Programmscan. Q wird TRUE, wenn CLK von TRUE auf FALSE wechselt."@de .

ag:Port_RS_Q1 a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q1" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q1 ist der gespeicherte Ausgang. Q1 bleibt erhalten, bis Reset aktiv wird."@de .

ag:Port_RS_R1 a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "R1" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "R1 ist der Reset Eingang mit Priorität. Wenn R1 TRUE ist, wird Q1 FALSE, auch wenn S TRUE ist."@de .

ag:Port_RS_S a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "S" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "S ist der Set Eingang. Wenn S TRUE wird und Reset nicht dominiert, wird Q1 TRUE."@de .

ag:Port_R_TRIG_CLK a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "CLK" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "CLK ist der BOOL Eingang, der überwacht wird. Bei einer steigenden Flanke wird Q erzeugt."@de .

ag:Port_R_TRIG_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q ist ein BOOL Impuls für einen Programmscan. Q wird TRUE, wenn CLK von FALSE auf TRUE wechselt."@de .

ag:Port_SR_Q1 a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q1" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q1 ist der gespeicherte Ausgang. Q1 bleibt erhalten, bis Reset aktiv wird."@de .

ag:Port_SR_R a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "R" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "R ist der Reset Eingang. Wenn R TRUE wird, wird Q1 gespeichert FALSE."@de .

ag:Port_SR_S1 a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "S1" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "S1 ist der Set Eingang. Wenn S1 TRUE wird, wird Q1 gespeichert TRUE."@de .

ag:Port_TOF_ET a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "ET" ;
    dp:hasPortType "TIME" ;
    rdfs:comment "ET ist die verstrichene Nachlaufzeit. ET zählt ab dem Abschalten von IN hoch bis PT."@de .

ag:Port_TOF_IN a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "IN" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "IN ist der BOOL Eingang. Wenn IN TRUE ist, ist Q TRUE. Bei fallender Flanke startet der Nachlauf."@de .

ag:Port_TOF_PT a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PT" ;
    dp:hasPortType "TIME" ;
    rdfs:comment "PT ist die Nachlaufzeit. Bestimmt wie lange Q nach dem Abschalten von IN noch TRUE bleibt."@de .

ag:Port_TOF_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q ist der BOOL Ausgang. Q bleibt nach fallender Flanke an IN noch für PT TRUE."@de .

ag:Port_TON_ET a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "ET" ;
    dp:hasPortType "TIME" ;
    rdfs:comment "ET ist die verstrichene Zeit seit Start. ET steigt bis maximal PT und dient oft zur Diagnose oder Visualisierung."@de .

ag:Port_TON_IN a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "IN" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "IN ist der BOOL Eingang zum Starten der Einschaltverzögerung. Wenn IN TRUE wird, läuft ET hoch."@de .

ag:Port_TON_PT a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PT" ;
    dp:hasPortType "TIME" ;
    rdfs:comment "PT ist die Vorgabezeit. IN muss mindestens so lange TRUE sein, damit Q TRUE wird."@de .

ag:Port_TON_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q ist der BOOL Ausgang. Q wird TRUE, wenn ET die Vorgabezeit PT erreicht und IN weiterhin TRUE ist."@de .

ag:Port_TP_ET a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "ET" ;
    dp:hasPortType "TIME" ;
    rdfs:comment "ET ist die verstrichene Zeit seit Impulsstart. Wird häufig für Anzeige und Diagnose genutzt."@de .

ag:Port_TP_IN a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "IN" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "IN ist der BOOL Trigger Eingang. Eine steigende Flanke startet den Impuls."@de .

ag:Port_TP_PT a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PT" ;
    dp:hasPortType "TIME" ;
    rdfs:comment "PT ist die Impulsdauer. Bestimmt wie lange Q TRUE bleibt."@de .

ag:Port_TP_Q a ag:class_Port,
        owl:NamedIndividual ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Q" ;
    dp:hasPortType "BOOL" ;
    rdfs:comment "Q ist der BOOL Ausgang des Impulses. Q ist für die Dauer PT TRUE."@de .

ag:Program_MAIN a ag:class_Program ;
    dp:hasPOUCode """// POU MAIN body
edgeDone(CLK := fbDiag.Diagnose_beendet);


Start_eff  := GVL.Start  OR edgeDone.Q;
Weiter_eff := GVL.Weiter OR edgeDone.Q;


fbBA(
    Start         := Start_eff,
    NotStop       := GVL.NotStopp,
    Weiter        := Weiter_eff,
    Fehler        := GVL.Fehler,
	Start_Init 	  := Init_start,                  
    Auto_Fertig   := fbAuto.Automatikbetrieb_Fertig,
    Auto_Stoerung := fbAuto.Stoerung_erkannt,
	A2_Requested := A2_angefordert,
	Alt_abort := alt_abort,
	Alt_found := alt_found,
	D3_Requested := D3_angefordert,
	Init_reached := Init_erreicht,
	Cycle_ended := Zyklus_beendet
);


edgeF1(CLK := fbBA.F1);
fbAuto(Automatikbetrieb_Starten := edgeF1.Q);

fbNot(D1 := fbBA.D1);
GVL.DiagnoseRequested := fbNot.Diagnose_gefordert;

fbProStoer(ProduktionMitStoerung_Starten := fbBA.D3);
alt_abort := fbProStoer.Stoerung_erkannt;


fbInit(A6 := fbBA.A6, A2 := fbBA.A2);
Init_erreicht := fbInit.Init_erreicht;


fbDiag(Diagnose_gefordert := fbBA.D2);
alt_found := fbDiag.Alt_gefunden;""" ;
    dp:hasPOUDeclarationHeader """PROGRAM MAIN
VAR
	{attribute 'OPC.UA.DA' := '1'}       // falls Server im Filter-/Symbolmodus
    fbJob : FB_Methode1Job;              // FB mit {attribute 'OPC.UA.DA.JobMethod' := 'M_Methode1'}
    fbBA   : FB_Betriebsarten;
    fbAuto : FB_Automatikbetrieb_F1;
    fbDiag : FB_Diagnose_D2;
	fbNot : FB_Notaus_D1;
	fbInit : FB_InitFahrt_A6_A2;
	fbProStoer : FB_ProduktionMitStoerung_D3;
	
	Init_start : BOOL := TRUE;
	

    edgeF1    : R_TRIG;  // F1 -> Start Automatik
    edgeDone  : R_TRIG;  // Diagnose_beendet -> Restart/Weiter
	alt_abort : BOOL := FALSE;
	alt_found : BOOL := FALSE;
    Start_eff  : BOOL := FALSE;
    Weiter_eff : BOOL := FALSE;
	A2_angefordert : BOOL := FALSE;
	D3_angefordert : BOOL := FALSE;
	Init_erreicht : BOOL := FALSE;
	Zyklus_beendet : BOOL := FALSE;
	
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "MAIN" ;
    dp:hasProgramName "MAIN" ;
    ag:op_hasInternalVariable ag:Var_MAIN_A2_angefordert,
        ag:Var_MAIN_D3_angefordert,
        ag:Var_MAIN_Init_erreicht,
        ag:Var_MAIN_Init_start,
        ag:Var_MAIN_Start_eff,
        ag:Var_MAIN_Weiter_eff,
        ag:Var_MAIN_Zyklus_beendet,
        ag:Var_MAIN_alt_abort,
        ag:Var_MAIN_alt_found,
        ag:Var_MAIN_edgeDone,
        ag:Var_MAIN_edgeF1,
        ag:Var_MAIN_fbAuto,
        ag:Var_MAIN_fbBA,
        ag:Var_MAIN_fbDiag,
        ag:Var_MAIN_fbInit,
        ag:Var_MAIN_fbJob,
        ag:Var_MAIN_fbNot,
        ag:Var_MAIN_fbProStoer ;
    ag:op_usesVariable ag:Var_MAIN_A2_angefordert,
        ag:Var_MAIN_D3_angefordert,
        ag:Var_MAIN_Init_erreicht,
        ag:Var_MAIN_Init_start,
        ag:Var_MAIN_Start_eff,
        ag:Var_MAIN_Weiter_eff,
        ag:Var_MAIN_Zyklus_beendet,
        ag:Var_MAIN_alt_abort,
        ag:Var_MAIN_alt_found,
        ag:Var_MAIN_edgeDone,
        ag:Var_MAIN_edgeF1,
        ag:Var_MAIN_fbAuto,
        ag:Var_MAIN_fbBA,
        ag:Var_MAIN_fbDiag,
        ag:Var_MAIN_fbInit,
        ag:Var_MAIN_fbJob,
        ag:Var_MAIN_fbNot,
        ag:Var_MAIN_fbProStoer .

ag:class_IOChannel a owl:Class ;
    rdfs:comment "Diese Klasse repräsentiert einen Hardwarekanal, also einen physikalischen Ein oder Ausgang, der in der Steuerung adressiert und mit Variablen verbunden werden kann. Ein IOChannel bildet damit die Brücke zwischen der semantischen Logik im Knowledge Graph und der realen Peripherie, etwa Sensoren, Ventile, Motoren oder Signallampen. Im Knowledge Graph wird ein IOChannel häufig genutzt, um Variablen mit Hardwareadressen zu verknüpfen und dadurch nachvollziehbar zu machen, welcher Code welche reale Komponente beeinflusst. Aus PLCopen XML kann ein IOChannel entweder direkt aus Hardwarezuordnungen oder indirekt aus Rohinformationen des Exports rekonstruiert werden, abhängig davon, wie vollständig das Mapping exportiert wurde. Die Klasse ist besonders wertvoll für Analysen, die Skill Ausführung mit physikalischen Effekten verbinden, da so sichtbar wird, welche Ausgänge ein Skill setzt und welche Eingänge er überwacht. Außerdem unterstützt sie Plausibilitätsprüfungen, beispielsweise ob ein Ausgang nur von einem Skill kontrolliert wird oder ob Konflikte zwischen mehreren Bausteinen existieren. Insgesamt macht class_IOChannel den Knowledge Graph hardware nah und damit für reale Automatisierungsszenarien aussagekräftig."@de .

ag:class_SourceLiteral a owl:Class ;
    rdfs:comment "Diese Klasse repräsentiert konstante Literalwerte, die in einem SPS Netzwerk direkt als Eingangswerte verwendet werden, zum Beispiel TRUE, FALSE, 0 oder Zeitkonstanten. Sie wird im Knowledge Graph als spezielle Form einer Signalquelle modelliert, damit Parameterzuweisungen auch dann sauber abgebildet werden können, wenn kein Variablenname existiert. Literale sind in vielen Steuerungslogiken wichtig, etwa um Defaultwerte zu setzen, Zustandsautomaten zu initialisieren oder Zeitparameter für Timer vorzugeben. Aus PLCopen XML lassen sich solche Literale häufig aus Parameterbelegungen erkennen, wenn ein Eingang nicht verdrahtet ist oder explizit mit einem konstanten Wert verbunden wird. Die Klasse ermöglicht es, den Datenfluss vollständig zu rekonstruieren, da sonst ein Teil der Eingänge als undefiniert erscheinen würde. In Skill Analysen helfen SourceLiterals dabei, feste Konfigurationen sichtbar zu machen, zum Beispiel konstante Verfahrzeiten oder feste Betriebsartenparameter. Damit trägt class_SourceLiteral zur Vollständigkeit und Nachvollziehbarkeit der Modellierung bei."@de ;
    rdfs:subClassOf ag:class_SignalSource .

ag:FBType_FB_Automatikbetrieb_F1 a ag:class_FBType ;
    dp:hasPOUCode """// POU FB_Automatikbetrieb_F1 body
IF GVL.Start THEN
	AutoRestartEnable := TRUE;
END_IF

rStart(CLK := Automatikbetrieb_Starten);
rStep1(CLK := Schritt1);


IF (AutoRestartEnable AND NOT (Schritt1 OR Schritt2)) OR (Stoerung_erkannt AND GVL.Weiter) THEN
    
	OPCUA.LastGEMMAStateBeforeFailure := 'F1';
    Automatikbetrieb_Fertig := FALSE;
    Stoerung_erkannt        := FALSE;
	GVL.Weiter := FALSE;
    
    Schritt1 := TRUE;
	OPCUA.lastExecutedProcess := 'ExTechnProcess1';
    Schritt2 := FALSE;
END_IF


tSchritt1(IN := Schritt1, PT := T#55S);
tSchritt2(IN := Schritt2, PT := T#55S);

IF rStep1.Q THEN
    lastSkillIsOne := NOT lastSkillIsOne;
    IF lastSkillIsOne THEN
        OPCUA.lastExecutedSkill := 'TestSkill3';
    ELSE
        OPCUA.lastExecutedSkill := 'TestSkill1';
    END_IF
END_IF

IF rStart.Q AND NOT (Schritt1 OR Schritt2) THEN
	OPCUA.LastGEMMAStateBeforeFailure := 'F1';
    Automatikbetrieb_Fertig := FALSE;
    Stoerung_erkannt := FALSE;
    GVL.Weiter := FALSE;
    Schritt1 := TRUE;
    Schritt2 := FALSE;
    OPCUA.lastExecutedProcess := 'ExTechnProcess1';
	OPCUA.LastGEMMAStateBeforeFailure := 'F1';
END_IF


IF NOT Stoerung_erkannt THEN
    
    IF Schritt1 AND tSchritt1.Q THEN
        Schritt1 := FALSE;
        Schritt2 := TRUE;
		OPCUA.lastExecutedSkill := 'TestSkill2';
		OPCUA.LastGEMMAStateBeforeFailure := 'F1';
    END_IF

    
    IF Schritt2 AND tSchritt2.Q THEN
        Schritt2 := FALSE;
        Automatikbetrieb_Fertig := TRUE;
        
    END_IF
END_IF


IF rtStoer.Q THEN
    Stoerung_erkannt := TRUE;
END_IF


tPer(IN := NOT tPer.Q, PT := PeriodicFaultPeriod);  


rPer(CLK := tPer.Q);
pPer(IN := rPer.Q, PT := FaultPulse);                


IF (Schritt1 OR Schritt2) AND pPer.Q THEN
    Stoerung_erkannt := TRUE;
	GVL.Fehler := TRUE;
END_IF""" ;
    dp:hasPOUDeclarationHeader """FUNCTION_BLOCK PUBLIC FB_Automatikbetrieb_F1
VAR_INPUT
    Automatikbetrieb_Starten : BOOL;
	AutoRestartEnable   : BOOL;      // Schalter für Autorestart
    // <<< NEU: parametrierbarer, periodischer Störgenerator >>>
    PeriodicFaultEnable : BOOL := TRUE;       // Ein/Aus
    PeriodicFaultPeriod : TIME := T#60s;      // z. B. jede Minute
    FaultPulse          : TIME := T#100ms;    // wie lange „Störung“ getriggert wird
END_VAR
VAR RETAIN
    lastSkillIsOne : BOOL := FALSE; // FALSE => erster Start wird TestSkill3 -> wir setzen gleich initial um
END_VAR
VAR_OUTPUT
    Automatikbetrieb_Fertig : BOOL;
    Stoerung_erkannt        : BOOL;
END_VAR
VAR
    Schritt1 : BOOL;
    Schritt2 : BOOL;
	Zwischen : STRING;
    tSchritt1 : TON;
    tSchritt2 : TON;
    rStart   : R_TRIG;
    rtStoer   : R_TRIG;
	rStep1 : R_TRIG;

    // <<< NEU >>>
    tPer   : TON;      // Periodentimer
    rPer   : R_TRIG;   // Flanke bei Periodenende
    pPer   : TP;       // kurzer Puls für die Störung
    perEn  : BOOL;     // Enable nur wenn die Automatik läuft
    dbg_Stoerung_Manuell : BOOL; // hattest du schon
	tpRestart: INT;
	RestartPulseLength: INT;
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "FB_Automatikbetrieb_F1" ;
    ag:op_hasInternalVariable ag:Var_FB_Automatikbetrieb_F1_AutoRestartEnable,
        ag:Var_FB_Automatikbetrieb_F1_Automatikbetrieb_Fertig,
        ag:Var_FB_Automatikbetrieb_F1_Automatikbetrieb_Starten,
        ag:Var_FB_Automatikbetrieb_F1_FaultPulse,
        ag:Var_FB_Automatikbetrieb_F1_PeriodicFaultEnable,
        ag:Var_FB_Automatikbetrieb_F1_PeriodicFaultPeriod,
        ag:Var_FB_Automatikbetrieb_F1_RestartPulseLength,
        ag:Var_FB_Automatikbetrieb_F1_Schritt1,
        ag:Var_FB_Automatikbetrieb_F1_Schritt2,
        ag:Var_FB_Automatikbetrieb_F1_Stoerung_erkannt,
        ag:Var_FB_Automatikbetrieb_F1_Zwischen,
        ag:Var_FB_Automatikbetrieb_F1_dbg_Stoerung_Manuell,
        ag:Var_FB_Automatikbetrieb_F1_lastSkillIsOne,
        ag:Var_FB_Automatikbetrieb_F1_pPer,
        ag:Var_FB_Automatikbetrieb_F1_perEn,
        ag:Var_FB_Automatikbetrieb_F1_rPer,
        ag:Var_FB_Automatikbetrieb_F1_rStart,
        ag:Var_FB_Automatikbetrieb_F1_rStep1,
        ag:Var_FB_Automatikbetrieb_F1_rtStoer,
        ag:Var_FB_Automatikbetrieb_F1_tPer,
        ag:Var_FB_Automatikbetrieb_F1_tSchritt1,
        ag:Var_FB_Automatikbetrieb_F1_tSchritt2,
        ag:Var_FB_Automatikbetrieb_F1_tpRestart ;
    ag:op_hasPort ag:Port_FB_Automatikbetrieb_F1_AutoRestartEnable,
        ag:Port_FB_Automatikbetrieb_F1_Automatikbetrieb_Fertig,
        ag:Port_FB_Automatikbetrieb_F1_Automatikbetrieb_Starten,
        ag:Port_FB_Automatikbetrieb_F1_FaultPulse,
        ag:Port_FB_Automatikbetrieb_F1_PeriodicFaultEnable,
        ag:Port_FB_Automatikbetrieb_F1_PeriodicFaultPeriod,
        ag:Port_FB_Automatikbetrieb_F1_Stoerung_erkannt ;
    ag:op_usesVariable ag:Var_FB_Automatikbetrieb_F1_AutoRestartEnable,
        ag:Var_FB_Automatikbetrieb_F1_Automatikbetrieb_Fertig,
        ag:Var_FB_Automatikbetrieb_F1_Automatikbetrieb_Starten,
        ag:Var_FB_Automatikbetrieb_F1_FaultPulse,
        ag:Var_FB_Automatikbetrieb_F1_PeriodicFaultEnable,
        ag:Var_FB_Automatikbetrieb_F1_PeriodicFaultPeriod,
        ag:Var_FB_Automatikbetrieb_F1_RestartPulseLength,
        ag:Var_FB_Automatikbetrieb_F1_Schritt1,
        ag:Var_FB_Automatikbetrieb_F1_Schritt2,
        ag:Var_FB_Automatikbetrieb_F1_Stoerung_erkannt,
        ag:Var_FB_Automatikbetrieb_F1_Zwischen,
        ag:Var_FB_Automatikbetrieb_F1_dbg_Stoerung_Manuell,
        ag:Var_FB_Automatikbetrieb_F1_lastSkillIsOne,
        ag:Var_FB_Automatikbetrieb_F1_pPer,
        ag:Var_FB_Automatikbetrieb_F1_perEn,
        ag:Var_FB_Automatikbetrieb_F1_rPer,
        ag:Var_FB_Automatikbetrieb_F1_rStart,
        ag:Var_FB_Automatikbetrieb_F1_rStep1,
        ag:Var_FB_Automatikbetrieb_F1_rtStoer,
        ag:Var_FB_Automatikbetrieb_F1_tPer,
        ag:Var_FB_Automatikbetrieb_F1_tSchritt1,
        ag:Var_FB_Automatikbetrieb_F1_tSchritt2,
        ag:Var_FB_Automatikbetrieb_F1_tpRestart .

ag:FBType_FB_Betriebsarten a ag:class_FBType ;
    dp:hasPOUCode """import time

def FB_Betriebsarten(V_10000000001: bool, D2: bool, A5: bool, GVL.Start: bool, A1: bool, D1: bool, D3: bool, V_30000000002: bool, V_30000000005: bool, GVL.Weiter: bool, GVL.NotStopp, A6, V_30000000011: bool, Auto_Stoerung, F1, GVL.DiagnoseRequested, Alt_abort, V_40000000012: bool, Alt_found, D3_Requested, A2, Init_reached, Cycle_ended, A2_Requested, Start_Init):
    \"\"\"Auto-generated from PLCopen XML (vereinfachte Semantik).\"\"\"

    def OR_1(V_10000000002, V_10000000003):
        result = D2 or A5
        return result
    V_10000000004 = OR_1(D2, A5)

    def RS_1(V_10000000001, V_10000000004):
        result = V_10000000004
        return result
    V_10000000005 = RS_1(V_10000000001, V_10000000004)

    def AND_1(V_20000000000, V_20000000001):
        result = GVL.Start and A1
        return result
    V_20000000002 = AND_1(GVL.Start, A1)

    def OR_2(V_20000000003, V_20000000004, V_20000000005):
        result = D2 or D1 or D3
        return result
    V_20000000006 = OR_2(D2, D1, D3)

    def RS_2(V_20000000002, V_20000000006):
        result = V_20000000006
        return result
    V_20000000007 = RS_2(V_20000000002, V_20000000006)

    def AND_2(V_30000000001, V_30000000002):
        result = D1 and V_30000000002
        return result
    V_30000000003 = AND_2(D1, V_30000000002)

    def OR_3(V_30000000000, V_30000000003):
        result = D2 or V_30000000003
        return result
    V_30000000004 = OR_3(D2, V_30000000003)

    def AND_3(V_30000000004, V_30000000005, V_30000000006, V_30000000007):
        result = V_30000000004 and V_30000000005 and GVL.Weiter and GVL.NotStopp
        return result
    V_30000000008 = AND_3(V_30000000004, V_30000000005, GVL.Weiter, GVL.NotStopp)

    def AND_4(V_30000000010, V_30000000011):
        result = D1 and V_30000000011
        return result
    V_30000000012 = AND_4(D1, V_30000000011)

    def OR_4(V_30000000009, V_30000000012):
        result = A6 or V_30000000012
        return result
    V_30000000013 = OR_4(A6, V_30000000012)

    def RS_3(V_30000000008, V_30000000013):
        result = V_30000000013
        return result
    V_30000000014 = RS_3(V_30000000008, V_30000000013)

    def AND_5(V_40000000000, V_40000000001):
        result = Auto_Stoerung and F1
        return result
    V_40000000002 = AND_5(Auto_Stoerung, F1)

    def AND_6(V_40000000003, V_40000000004, V_40000000005):
        result = GVL.DiagnoseRequested and D1 and GVL.NotStopp
        return result
    V_40000000006 = AND_6(GVL.DiagnoseRequested, D1, GVL.NotStopp)

    def AND_7(V_40000000007, V_40000000008):
        result = D3 and Alt_abort
        return result
    V_40000000009 = AND_7(D3, Alt_abort)

    def OR_5(V_40000000002, V_40000000006, V_40000000009):
        result = V_40000000002 or V_40000000006 or V_40000000009
        return result
    V_40000000010 = OR_5(V_40000000002, V_40000000006, V_40000000009)

    def AND_8(V_40000000011, V_40000000012):
        result = D1 and V_40000000012
        return result
    V_40000000013 = AND_8(D1, V_40000000012)

    def OR_6(V_40000000013, V_40000000014, V_40000000015):
        result = V_40000000013 or D3 or A5
        return result
    V_40000000016 = OR_6(V_40000000013, D3, A5)

    def RS_4(V_40000000010, V_40000000016):
        result = V_40000000016
        return result
    V_40000000017 = RS_4(V_40000000010, V_40000000016)

    def AND_9(V_50000000000, V_50000000001):
        result = D2 and Alt_found
        return result
    V_50000000002 = AND_9(D2, Alt_found)

    def AND_10(V_50000000003, V_50000000004):
        result = F1 and D3_Requested
        return result
    V_50000000005 = AND_10(F1, D3_Requested)

    def OR_7(V_50000000002, V_50000000005):
        result = V_50000000002 or V_50000000005
        return result
    V_50000000006 = OR_7(V_50000000002, V_50000000005)

    def OR_8(V_50000000007, V_50000000008, V_50000000009):
        result = A2 or D1 or D2
        return result
    V_50000000010 = OR_8(A2, D1, D2)

    def RS_5(V_50000000006, V_50000000010):
        result = V_50000000010
        return result
    V_50000000011 = RS_5(V_50000000006, V_50000000010)

    def AND_11(V_60000000000, V_60000000001):
        result = A6 and Init_reached
        return result
    V_60000000002 = AND_11(A6, Init_reached)

    def AND_12(V_60000000003, V_60000000004, V_60000000005):
        result = A2 and Init_reached and Cycle_ended
        return result
    V_60000000006 = AND_12(A2, Init_reached, Cycle_ended)

    def OR_9(V_60000000002, V_60000000006):
        result = V_60000000002 or V_60000000006
        return result
    V_60000000007 = OR_9(V_60000000002, V_60000000006)

    def OR_10(V_60000000008, V_60000000009):
        result = F1 or D1
        return result
    V_60000000010 = OR_10(F1, D1)

    def RS_6(V_60000000007, V_60000000010):
        result = V_60000000010
        return result
    V_60000000011 = RS_6(V_60000000007, V_60000000010)

    def AND_13(V_70000000000, V_70000000001):
        result = D3 and A2_Requested
        return result
    V_70000000002 = AND_13(D3, A2_Requested)

    def OR_11(V_70000000003, V_70000000004):
        result = A1 or D1
        return result
    V_70000000005 = OR_11(A1, D1)

    def RS_7(V_70000000002, V_70000000005):
        result = V_70000000005
        return result
    V_70000000006 = RS_7(V_70000000002, V_70000000005)

    def R_TRIG(V_80000000000):
        result = Start_Init
        return result
    V_80000000001 = R_TRIG(Start_Init)

    def OR_12(V_80000000001, V_80000000002):
        result = V_80000000001 or A5
        return result
    V_80000000003 = OR_12(V_80000000001, A5)

    def OR_13(V_80000000004, V_80000000005):
        result = A1 or D1
        return result
    V_80000000006 = OR_13(A1, D1)

    def RS_8(V_80000000003, V_80000000006):
        result = V_80000000006
        return result
    V_80000000007 = RS_8(V_80000000003, V_80000000006)
    D1 = V_10000000005
    print('Value of D1:', D1)
    F1 = V_20000000007
    print('Value of F1:', F1)
    A5 = V_30000000014
    print('Value of A5:', A5)
    D2 = V_40000000017
    print('Value of D2:', D2)
    D3 = V_50000000011
    print('Value of D3:', D3)
    A1 = V_60000000011
    print('Value of A1:', A1)
    A2 = V_70000000006
    print('Value of A2:', A2)
    A6 = V_80000000007
    print('Value of A6:', A6)
    return {'D1': D1, 'F1': F1, 'A5': A5, 'D2': D2, 'D3': D3, 'A1': A1, 'A2': A2, 'A6': A6}""" ;
    dp:hasPOUDeclarationHeader """FUNCTION_BLOCK FB_Betriebsarten
VAR_INPUT
	Start, NotStop, Weiter, Fehler, Start_Init : BOOL;
    Auto_Fertig   : BOOL; // kommt von fbAuto.Automatikbetrieb_Fertig
    Auto_Stoerung : BOOL; // kommt von fbAuto.Stoerung_erkannt
	A2_Requested: BOOL;
	Alt_abort: BOOL;
	Alt_found: BOOL;
	D3_Requested: BOOL;
	Init_reached: BOOL;
	Cycle_ended: BOOL;
	//Reset			: BOOL;
	//Schalter		: BOOL;
	//Schrittkette_GS : BOOL;
END_VAR
VAR_OUTPUT
	A1 : BOOL; //Initialzustand
	A2 : BOOL; //Stillstand angefordert am Ende des Zyklus
//	A3 : BOOL; //Stillstand angefordert in einem bestimmten Zustand
//	A4 : BOOL; //Erhaltener Stillstand
	A5 : BOOL; //Vorbereitung zur Wiederaufnahme nach Störung
	A6 : BOOL; //Fahrt in den Initialzustand
	F1 : BOOL; //Normalbetrieb
//	F2 : BOOL; //Anfahren
//	F3 : BOOL; //Abfahren
	F4 : BOOL; //Handbetrieb
//	F5 : BOOL; //Schrittbetrieb
//	F6 : BOOL; //Testbetrieb
	D1 : BOOL; //Not-Aus
	D2 : BOOL; //DIagnose und Störbehandlung
	D3 : BOOL; //Produktion trotz Störung
END_VAR
VAR
	bFirstScan : BOOL := TRUE;	

	RS_InitialState: RS;	
	RS_InitialDrive: RS;
	RS_ManualOperationMode: RS;
	RS_AutomaticOperationMode: RS;
	RS_CycleEnded: RS;

	R_TRIG_Manual: R_TRIG;
	R_TRIG_Automatic: R_TRIG;
	R_TRIG_InitialDrive: R_TRIG;
	R_TRIG_CycleEnded: R_TRIG;
	R_TRIG_Init: R_TRIG;
	RS_D2: RS;
	RS_F1: RS;
	RS_D1: RS;
	RS_A5: RS;
	RS_A1: RS;

	RS_D3: RS;

	RS_A2: RS;
	RS_A6: RS;
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "FBD" ;
    dp:hasPOUName "FB_Betriebsarten" ;
    ag:op_hasInternalVariable ag:Var_FB_Betriebsarten_A1,
        ag:Var_FB_Betriebsarten_A2,
        ag:Var_FB_Betriebsarten_A2_Requested,
        ag:Var_FB_Betriebsarten_A5,
        ag:Var_FB_Betriebsarten_A6,
        ag:Var_FB_Betriebsarten_Alt_abort,
        ag:Var_FB_Betriebsarten_Alt_found,
        ag:Var_FB_Betriebsarten_Auto_Fertig,
        ag:Var_FB_Betriebsarten_Auto_Stoerung,
        ag:Var_FB_Betriebsarten_Cycle_ended,
        ag:Var_FB_Betriebsarten_D1,
        ag:Var_FB_Betriebsarten_D2,
        ag:Var_FB_Betriebsarten_D3,
        ag:Var_FB_Betriebsarten_D3_Requested,
        ag:Var_FB_Betriebsarten_F1,
        ag:Var_FB_Betriebsarten_F4,
        ag:Var_FB_Betriebsarten_Fehler,
        ag:Var_FB_Betriebsarten_Init_reached,
        ag:Var_FB_Betriebsarten_NotStop,
        ag:Var_FB_Betriebsarten_RS_A1,
        ag:Var_FB_Betriebsarten_RS_A2,
        ag:Var_FB_Betriebsarten_RS_A5,
        ag:Var_FB_Betriebsarten_RS_A6,
        ag:Var_FB_Betriebsarten_RS_AutomaticOperationMode,
        ag:Var_FB_Betriebsarten_RS_CycleEnded,
        ag:Var_FB_Betriebsarten_RS_D1,
        ag:Var_FB_Betriebsarten_RS_D2,
        ag:Var_FB_Betriebsarten_RS_D3,
        ag:Var_FB_Betriebsarten_RS_F1,
        ag:Var_FB_Betriebsarten_RS_InitialDrive,
        ag:Var_FB_Betriebsarten_RS_InitialState,
        ag:Var_FB_Betriebsarten_RS_ManualOperationMode,
        ag:Var_FB_Betriebsarten_R_TRIG_Automatic,
        ag:Var_FB_Betriebsarten_R_TRIG_CycleEnded,
        ag:Var_FB_Betriebsarten_R_TRIG_Init,
        ag:Var_FB_Betriebsarten_R_TRIG_InitialDrive,
        ag:Var_FB_Betriebsarten_R_TRIG_Manual,
        ag:Var_FB_Betriebsarten_Start,
        ag:Var_FB_Betriebsarten_Start_Init,
        ag:Var_FB_Betriebsarten_Weiter,
        ag:Var_FB_Betriebsarten_bFirstScan ;
    ag:op_hasPort ag:Port_FB_Betriebsarten_A1,
        ag:Port_FB_Betriebsarten_A2,
        ag:Port_FB_Betriebsarten_A2_Requested,
        ag:Port_FB_Betriebsarten_A5,
        ag:Port_FB_Betriebsarten_A6,
        ag:Port_FB_Betriebsarten_Alt_abort,
        ag:Port_FB_Betriebsarten_Alt_found,
        ag:Port_FB_Betriebsarten_Auto_Fertig,
        ag:Port_FB_Betriebsarten_Auto_Stoerung,
        ag:Port_FB_Betriebsarten_Cycle_ended,
        ag:Port_FB_Betriebsarten_D1,
        ag:Port_FB_Betriebsarten_D2,
        ag:Port_FB_Betriebsarten_D3,
        ag:Port_FB_Betriebsarten_D3_Requested,
        ag:Port_FB_Betriebsarten_F1,
        ag:Port_FB_Betriebsarten_F4,
        ag:Port_FB_Betriebsarten_Fehler,
        ag:Port_FB_Betriebsarten_Init_reached,
        ag:Port_FB_Betriebsarten_NotStop,
        ag:Port_FB_Betriebsarten_Start,
        ag:Port_FB_Betriebsarten_Start_Init,
        ag:Port_FB_Betriebsarten_Weiter ;
    ag:op_usesVariable ag:Var_FB_Betriebsarten_A1,
        ag:Var_FB_Betriebsarten_A2,
        ag:Var_FB_Betriebsarten_A2_Requested,
        ag:Var_FB_Betriebsarten_A5,
        ag:Var_FB_Betriebsarten_A6,
        ag:Var_FB_Betriebsarten_Alt_abort,
        ag:Var_FB_Betriebsarten_Alt_found,
        ag:Var_FB_Betriebsarten_Auto_Fertig,
        ag:Var_FB_Betriebsarten_Auto_Stoerung,
        ag:Var_FB_Betriebsarten_Cycle_ended,
        ag:Var_FB_Betriebsarten_D1,
        ag:Var_FB_Betriebsarten_D2,
        ag:Var_FB_Betriebsarten_D3,
        ag:Var_FB_Betriebsarten_D3_Requested,
        ag:Var_FB_Betriebsarten_F1,
        ag:Var_FB_Betriebsarten_F4,
        ag:Var_FB_Betriebsarten_Fehler,
        ag:Var_FB_Betriebsarten_Init_reached,
        ag:Var_FB_Betriebsarten_NotStop,
        ag:Var_FB_Betriebsarten_RS_A1,
        ag:Var_FB_Betriebsarten_RS_A2,
        ag:Var_FB_Betriebsarten_RS_A5,
        ag:Var_FB_Betriebsarten_RS_A6,
        ag:Var_FB_Betriebsarten_RS_AutomaticOperationMode,
        ag:Var_FB_Betriebsarten_RS_CycleEnded,
        ag:Var_FB_Betriebsarten_RS_D1,
        ag:Var_FB_Betriebsarten_RS_D2,
        ag:Var_FB_Betriebsarten_RS_D3,
        ag:Var_FB_Betriebsarten_RS_F1,
        ag:Var_FB_Betriebsarten_RS_InitialDrive,
        ag:Var_FB_Betriebsarten_RS_InitialState,
        ag:Var_FB_Betriebsarten_RS_ManualOperationMode,
        ag:Var_FB_Betriebsarten_R_TRIG_Automatic,
        ag:Var_FB_Betriebsarten_R_TRIG_CycleEnded,
        ag:Var_FB_Betriebsarten_R_TRIG_Init,
        ag:Var_FB_Betriebsarten_R_TRIG_InitialDrive,
        ag:Var_FB_Betriebsarten_R_TRIG_Manual,
        ag:Var_FB_Betriebsarten_Start,
        ag:Var_FB_Betriebsarten_Start_Init,
        ag:Var_FB_Betriebsarten_Weiter,
        ag:Var_FB_Betriebsarten_bFirstScan .

ag:FBType_FB_Diagnose_D2 a ag:class_FBType ;
    dp:hasPOUCode """// POU FB_Diagnose_D2 body
rtReq(CLK := Diagnose_gefordert);


IF rtReq.Q AND NOT Busy THEN
    Busy := TRUE;
	Alt_gefunden := FALSE;
	OPCUA.TriggerD2 := TRUE; 
	OPCUA.bool1 := TRUE;
END_IF

  



rtAck(CLK := OPCUA.DiagnoseFinished);
rtD3(CLK := OPCUA.Alt_found);
IF rtAck.Q OR rtD3.Q THEN
    Diagnose_beendet := TRUE;
    GVL.Weiter := TRUE;
    Busy := FALSE;
    OPCUA.TriggerD2 := FALSE;
	OPCUA.bool2 := FALSE;
    GVL.Fehler := FALSE;
    Diagnose_gefordert := FALSE;
	GVL.DiagnoseRequested := FALSE;
END_IF
IF rtD3.Q THEN
	Alt_gefunden := TRUE;
END_IF""" ;
    dp:hasPOUDeclarationHeader """FUNCTION_BLOCK PUBLIC FB_Diagnose_D2
VAR_INPUT
    Diagnose_gefordert         : BOOL;  // z. B. D2 aus FB_Betriebsarten
END_VAR
VAR_OUTPUT
    Diagnose_beendet           : BOOL;  // geht zurück an FB_Betriebsarten
	Alt_gefunden			   : BOOL := FALSE;
END_VAR
VAR
    // Steuerung/Handshake intern
    Busy       : BOOL;

    // Flanken + Puls
    rtReq      : R_TRIG;    // steigende Flanke auf Diagnose_gefordert
	rtD3 : R_TRIG;
    tpPulse    : TP;        // kurzer Puls für OPCUA.TriggerD2 (z. B. 100 ms)
    rtFinished : R_TRIG;    // steigende Flanke auf OPCUA.DiagnoseFinished
	 rtAck : R_TRIG;
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "FB_Diagnose_D2" ;
    ag:op_hasInternalVariable ag:Var_FB_Diagnose_D2_Alt_gefunden,
        ag:Var_FB_Diagnose_D2_Busy,
        ag:Var_FB_Diagnose_D2_Diagnose_beendet,
        ag:Var_FB_Diagnose_D2_Diagnose_gefordert,
        ag:Var_FB_Diagnose_D2_rtAck,
        ag:Var_FB_Diagnose_D2_rtD3,
        ag:Var_FB_Diagnose_D2_rtFinished,
        ag:Var_FB_Diagnose_D2_rtReq,
        ag:Var_FB_Diagnose_D2_tpPulse ;
    ag:op_hasPort ag:Port_FB_Diagnose_D2_Alt_gefunden,
        ag:Port_FB_Diagnose_D2_Diagnose_beendet,
        ag:Port_FB_Diagnose_D2_Diagnose_gefordert ;
    ag:op_usesVariable ag:Var_FB_Diagnose_D2_Alt_gefunden,
        ag:Var_FB_Diagnose_D2_Busy,
        ag:Var_FB_Diagnose_D2_Diagnose_beendet,
        ag:Var_FB_Diagnose_D2_Diagnose_gefordert,
        ag:Var_FB_Diagnose_D2_rtAck,
        ag:Var_FB_Diagnose_D2_rtD3,
        ag:Var_FB_Diagnose_D2_rtFinished,
        ag:Var_FB_Diagnose_D2_rtReq,
        ag:Var_FB_Diagnose_D2_tpPulse .

ag:FBType_FB_InitFahrt_A6_A2 a ag:class_FBType ;
    dp:hasPOUCode """// POU FB_InitFahrt_A6_A2 body
IF A6 THEN
	tInit(IN := A6, PT := T#3S);
	OPCUA.LastGEMMAStateBeforeFailure := 'A6';
ELSIF A2 THEN
	tInit(IN := A2, PT := T#5S);
	OPCUA.LastGEMMAStateBeforeFailure := 'A2';
END_IF

IF tInit.Q THEN
	Init_erreicht := TRUE;
ELSE
	Init_erreicht := FALSE;
END_IF""" ;
    dp:hasPOUDeclarationHeader """FUNCTION_BLOCK FB_InitFahrt_A6_A2
VAR_INPUT
	A6 : BOOL := FALSE;
	A2: BOOL := FALSE;
END_VAR
VAR_OUTPUT
	Init_erreicht : BOOL := FALSE;
END_VAR
VAR
	tInit : TON;
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "FB_InitFahrt_A6_A2" ;
    ag:op_hasInternalVariable ag:Var_FB_InitFahrt_A6_A2_A2,
        ag:Var_FB_InitFahrt_A6_A2_A6,
        ag:Var_FB_InitFahrt_A6_A2_Init_erreicht,
        ag:Var_FB_InitFahrt_A6_A2_tInit ;
    ag:op_hasPort ag:Port_FB_InitFahrt_A6_A2_A2,
        ag:Port_FB_InitFahrt_A6_A2_A6,
        ag:Port_FB_InitFahrt_A6_A2_Init_erreicht ;
    ag:op_usesVariable ag:Var_FB_InitFahrt_A6_A2_A2,
        ag:Var_FB_InitFahrt_A6_A2_A6,
        ag:Var_FB_InitFahrt_A6_A2_Init_erreicht,
        ag:Var_FB_InitFahrt_A6_A2_tInit .

ag:FBType_FB_Methode1Job a ag:class_FBType ;
    dp:hasPOUCode """// METHOD Abort of FB_Methode1Job
running := FALSE;
Abort := 0;

// METHOD CheckState of FB_Methode1Job
IF running THEN
	
    
    
        
    
	reached := TRUE;

    
    t20s(IN := reached, PT := T#9S);

    IF reached AND t20s.Q THEN
        y := 119;
        running := FALSE;
    END_IF
END_IF

bBusy := running;
yOut  := y;
CheckState := 0;

// METHOD Start of FB_Methode1Job
counter := x;
reached := FALSE;
running := TRUE;
t20s(IN := FALSE, PT := T#9S);   
hdl := 0;                         
Start := 0;""" ;
    dp:hasPOUDeclarationHeader """{attribute 'OPC.UA.DA.JobMethod' := 'M_Methode1'} // Dieser FB wird als OPC-UA-Job "M_Methode1" veröffentlicht
FUNCTION_BLOCK FB_Methode1Job
VAR
    running : BOOL := FALSE;
    counter : DINT := 0;
    reached : BOOL := FALSE;
    t20s    : TON;        // 20-s-Timer, läuft zyklisch
    y       : DINT := 0;  // Ergebnis
END_VAR
// Wichtig: Bei Job-Methoden deklariert man den Funktionsbaustein mit
//{attribute 'OPC.UA.DA.JobMethod' := 'NameDerUAMethod'}
//und markiert die drei PLC-METHODs Start, CheckState, Abort jeweils mit TcRpcEnable. 
//CheckState besitzt zwingend das Output bBusy, über das der Server erkennt, ob der Job noch läuft."""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "FB_Methode1Job" ;
    ag:op_hasInternalVariable ag:Var_FB_Methode1Job_counter,
        ag:Var_FB_Methode1Job_reached,
        ag:Var_FB_Methode1Job_running,
        ag:Var_FB_Methode1Job_t20s,
        ag:Var_FB_Methode1Job_y ;
    ag:op_usesVariable ag:Var_FB_Methode1Job_counter,
        ag:Var_FB_Methode1Job_reached,
        ag:Var_FB_Methode1Job_running,
        ag:Var_FB_Methode1Job_t20s,
        ag:Var_FB_Methode1Job_y .

ag:FBType_FB_Notaus_D1 a ag:class_FBType ;
    dp:hasPOUCode """// POU FB_Notaus_D1 body
IF D1 THEN
    OPCUA.TriggerD1 := TRUE;         
    ton5s(IN := TRUE, PT := T#5S);
ELSE
    ton5s(IN := FALSE, PT := T#5S);
END_IF;

IF ton5s.Q THEN
    OPCUA.TriggerD1 := FALSE;
    Diagnose_gefordert := FALSE;
    GVL.NotStopp := TRUE;
    GVL.Fehler := FALSE;
    GVL.Weiter := TRUE;
END_IF;""" ;
    dp:hasPOUDeclarationHeader """FUNCTION_BLOCK FB_Notaus_D1
VAR_INPUT
	D1 : BOOL;
END_VAR
VAR_OUTPUT
	Notaus_Entriegelt : BOOL;
	Diagnose_gefordert : BOOL;
END_VAR
VAR
	ton5s : TON;
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "FB_Notaus_D1" ;
    ag:op_hasInternalVariable ag:Var_FB_Notaus_D1_D1,
        ag:Var_FB_Notaus_D1_Diagnose_gefordert,
        ag:Var_FB_Notaus_D1_Notaus_Entriegelt,
        ag:Var_FB_Notaus_D1_ton5s ;
    ag:op_hasPort ag:Port_FB_Notaus_D1_D1,
        ag:Port_FB_Notaus_D1_Diagnose_gefordert,
        ag:Port_FB_Notaus_D1_Notaus_Entriegelt ;
    ag:op_usesVariable ag:Var_FB_Notaus_D1_D1,
        ag:Var_FB_Notaus_D1_Diagnose_gefordert,
        ag:Var_FB_Notaus_D1_Notaus_Entriegelt,
        ag:Var_FB_Notaus_D1_ton5s .

ag:FBType_FB_ProduktionMitStoerung_D3 a ag:class_FBType ;
    dp:hasPOUCode """// POU FB_ProduktionMitStoerung_D3 body
rStart(CLK := ProduktionMitStoerung_Starten);
IF rStart.Q THEN
	z := 0;
END_IF

IF ProduktionMitStoerung_Starten AND NOT (Schritt3 OR Schritt4) AND NOT Stoerung_erkannt THEN
	Fertig := FALSE;
	Schritt3 := TRUE;
	OPCUA.lastExecutedSkill := 'TestSkill3';
	OPCUA.lastExecutedProcess := 'D3Process';
	Schritt4 := FALSE;
END_IF

tSchritt3(IN := Schritt3, PT:=T#10S);
tSchritt4(IN := Schritt4, PT:=T#10S);

IF tSchritt3.Q THEN
	Schritt3 := FALSE;
	z := z+1;
	IF z > 2 THEN
		Stoerung_erkannt := TRUE;
		OPCUA.Alt_abort := TRUE;
	END_IF
	IF NOT Stoerung_erkannt THEN
		Schritt4 := TRUE;
		OPCUA.lastExecutedSkill := 'TestSkill4';
	END_IF
END_IF

IF tSchritt4.Q THEN
	Schritt4 := FALSE;
	Schritt3 := TRUE;
	OPCUA.lastExecutedSkill := 'TestSkill3';
END_IF""" ;
    dp:hasPOUDeclarationHeader """FUNCTION_BLOCK FB_ProduktionMitStoerung_D3
VAR_INPUT
    ProduktionMitStoerung_Starten : BOOL;
END_VAR
VAR RETAIN
    lastSkillIsOne : BOOL := FALSE; // FALSE => erster Start wird TestSkill3 -> wir setzen gleich initial um
END_VAR
VAR_OUTPUT
    Fertig : BOOL;
    Stoerung_erkannt        : BOOL;
END_VAR
VAR
    Schritt3 : BOOL;
    Schritt4 : BOOL;
	Zwischen : STRING;
    tSchritt3 : TON;
    tSchritt4 : TON;
    rStart   : R_TRIG;
    rtStoer   : R_TRIG;
	rStep1 : R_TRIG;
	z : INT := 0;

    // <<< NEU >>>
    tPer   : TON;      // Periodentimer
    rPer   : R_TRIG;   // Flanke bei Periodenende
    pPer   : TP;       // kurzer Puls für die Störung
    perEn  : BOOL;     // Enable nur wenn die Automatik läuft
    dbg_Stoerung_Manuell : BOOL; // hattest du schon
	tpRestart: INT;
	RestartPulseLength: INT;
END_VAR"""^^xsd:string ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "FB_ProduktionMitStoerung_D3" ;
    ag:op_hasInternalVariable ag:Var_FB_ProduktionMitStoerung_D3_Fertig,
        ag:Var_FB_ProduktionMitStoerung_D3_ProduktionMitStoerung_Starten,
        ag:Var_FB_ProduktionMitStoerung_D3_RestartPulseLength,
        ag:Var_FB_ProduktionMitStoerung_D3_Schritt3,
        ag:Var_FB_ProduktionMitStoerung_D3_Schritt4,
        ag:Var_FB_ProduktionMitStoerung_D3_Stoerung_erkannt,
        ag:Var_FB_ProduktionMitStoerung_D3_Zwischen,
        ag:Var_FB_ProduktionMitStoerung_D3_dbg_Stoerung_Manuell,
        ag:Var_FB_ProduktionMitStoerung_D3_lastSkillIsOne,
        ag:Var_FB_ProduktionMitStoerung_D3_pPer,
        ag:Var_FB_ProduktionMitStoerung_D3_perEn,
        ag:Var_FB_ProduktionMitStoerung_D3_rPer,
        ag:Var_FB_ProduktionMitStoerung_D3_rStart,
        ag:Var_FB_ProduktionMitStoerung_D3_rStep1,
        ag:Var_FB_ProduktionMitStoerung_D3_rtStoer,
        ag:Var_FB_ProduktionMitStoerung_D3_tPer,
        ag:Var_FB_ProduktionMitStoerung_D3_tSchritt3,
        ag:Var_FB_ProduktionMitStoerung_D3_tSchritt4,
        ag:Var_FB_ProduktionMitStoerung_D3_tpRestart,
        ag:Var_FB_ProduktionMitStoerung_D3_z ;
    ag:op_hasPort ag:Port_FB_ProduktionMitStoerung_D3_Fertig,
        ag:Port_FB_ProduktionMitStoerung_D3_ProduktionMitStoerung_Starten,
        ag:Port_FB_ProduktionMitStoerung_D3_Stoerung_erkannt ;
    ag:op_usesVariable ag:Var_FB_ProduktionMitStoerung_D3_Fertig,
        ag:Var_FB_ProduktionMitStoerung_D3_ProduktionMitStoerung_Starten,
        ag:Var_FB_ProduktionMitStoerung_D3_RestartPulseLength,
        ag:Var_FB_ProduktionMitStoerung_D3_Schritt3,
        ag:Var_FB_ProduktionMitStoerung_D3_Schritt4,
        ag:Var_FB_ProduktionMitStoerung_D3_Stoerung_erkannt,
        ag:Var_FB_ProduktionMitStoerung_D3_Zwischen,
        ag:Var_FB_ProduktionMitStoerung_D3_dbg_Stoerung_Manuell,
        ag:Var_FB_ProduktionMitStoerung_D3_lastSkillIsOne,
        ag:Var_FB_ProduktionMitStoerung_D3_pPer,
        ag:Var_FB_ProduktionMitStoerung_D3_perEn,
        ag:Var_FB_ProduktionMitStoerung_D3_rPer,
        ag:Var_FB_ProduktionMitStoerung_D3_rStart,
        ag:Var_FB_ProduktionMitStoerung_D3_rStep1,
        ag:Var_FB_ProduktionMitStoerung_D3_rtStoer,
        ag:Var_FB_ProduktionMitStoerung_D3_tPer,
        ag:Var_FB_ProduktionMitStoerung_D3_tSchritt3,
        ag:Var_FB_ProduktionMitStoerung_D3_tSchritt4,
        ag:Var_FB_ProduktionMitStoerung_D3_tpRestart,
        ag:Var_FB_ProduktionMitStoerung_D3_z .

ag:Port_FB_Automatikbetrieb_F1_AutoRestartEnable a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "AutoRestartEnable" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Automatikbetrieb_F1_Automatikbetrieb_Fertig a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Automatikbetrieb_Fertig" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Automatikbetrieb_F1_Automatikbetrieb_Starten a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Automatikbetrieb_Starten" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Automatikbetrieb_F1_FaultPulse a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "FaultPulse" ;
    dp:hasPortType "TIME" .

ag:Port_FB_Automatikbetrieb_F1_PeriodicFaultEnable a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PeriodicFaultEnable" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Automatikbetrieb_F1_PeriodicFaultPeriod a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "PeriodicFaultPeriod" ;
    dp:hasPortType "TIME" .

ag:Port_FB_Automatikbetrieb_F1_Stoerung_erkannt a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Stoerung_erkannt" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_A1 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "A1" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_A2 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "A2" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_A2_Requested a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "A2_Requested" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_A5 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "A5" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_A6 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "A6" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Alt_abort a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Alt_abort" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Alt_found a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Alt_found" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Auto_Fertig a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Auto_Fertig" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Auto_Stoerung a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Auto_Stoerung" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Cycle_ended a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Cycle_ended" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_D1 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "D1" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_D2 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "D2" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_D3 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "D3" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_D3_Requested a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "D3_Requested" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_F1 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "F1" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_F4 a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "F4" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Init_reached a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Init_reached" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_NotStop a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "NotStop" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Start_Init a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Start_Init" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Diagnose_D2_Alt_gefunden a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Alt_gefunden" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Diagnose_D2_Diagnose_beendet a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Diagnose_beendet" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Diagnose_D2_Diagnose_gefordert a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Diagnose_gefordert" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_InitFahrt_A6_A2_A2 a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "A2" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_InitFahrt_A6_A2_A6 a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "A6" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_InitFahrt_A6_A2_Init_erreicht a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Init_erreicht" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Notaus_D1_D1 a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "D1" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Notaus_D1_Diagnose_gefordert a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Diagnose_gefordert" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Notaus_D1_Notaus_Entriegelt a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Notaus_Entriegelt" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_ProduktionMitStoerung_D3_Fertig a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Fertig" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_ProduktionMitStoerung_D3_ProduktionMitStoerung_Starten a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "ProduktionMitStoerung_Starten" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_ProduktionMitStoerung_D3_Stoerung_erkannt a ag:class_Port ;
    dp:hasPortDirection "Output" ;
    dp:hasPortName "Stoerung_erkannt" ;
    dp:hasPortType "BOOL" .

ag:Var_FB_Automatikbetrieb_F1_AutoRestartEnable a ag:class_Variable ;
    dp:hasVariableName "AutoRestartEnable" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_AutoRestartEnable .

ag:Var_FB_Automatikbetrieb_F1_Automatikbetrieb_Fertig a ag:class_Variable ;
    dp:hasVariableName "Automatikbetrieb_Fertig" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_Automatikbetrieb_Fertig .

ag:Var_FB_Automatikbetrieb_F1_Automatikbetrieb_Starten a ag:class_Variable ;
    dp:hasVariableName "Automatikbetrieb_Starten" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_Automatikbetrieb_Starten .

ag:Var_FB_Automatikbetrieb_F1_FaultPulse a ag:class_Variable ;
    dp:hasVariableName "FaultPulse" ;
    dp:hasVariableType "TIME" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_FaultPulse .

ag:Var_FB_Automatikbetrieb_F1_PeriodicFaultEnable a ag:class_Variable ;
    dp:hasVariableName "PeriodicFaultEnable" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_PeriodicFaultEnable .

ag:Var_FB_Automatikbetrieb_F1_PeriodicFaultPeriod a ag:class_Variable ;
    dp:hasVariableName "PeriodicFaultPeriod" ;
    dp:hasVariableType "TIME" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_PeriodicFaultPeriod .

ag:Var_FB_Automatikbetrieb_F1_RestartPulseLength a ag:class_Variable ;
    dp:hasVariableName "RestartPulseLength" ;
    dp:hasVariableType "INT" .

ag:Var_FB_Automatikbetrieb_F1_Schritt1 a ag:class_Variable ;
    dp:hasVariableName "Schritt1" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Automatikbetrieb_F1_Schritt2 a ag:class_Variable ;
    dp:hasVariableName "Schritt2" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Automatikbetrieb_F1_Stoerung_erkannt a ag:class_Variable ;
    dp:hasVariableName "Stoerung_erkannt" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Automatikbetrieb_F1_Stoerung_erkannt .

ag:Var_FB_Automatikbetrieb_F1_Zwischen a ag:class_Variable ;
    dp:hasVariableName "Zwischen" ;
    dp:hasVariableType "string" .

ag:Var_FB_Automatikbetrieb_F1_dbg_Stoerung_Manuell a ag:class_Variable ;
    dp:hasVariableName "dbg_Stoerung_Manuell" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Automatikbetrieb_F1_lastSkillIsOne a ag:class_Variable ;
    dp:hasVariableName "lastSkillIsOne" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Automatikbetrieb_F1_pPer a ag:class_Variable ;
    dp:hasVariableName "pPer" ;
    dp:hasVariableType "TP" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_pPer .

ag:Var_FB_Automatikbetrieb_F1_perEn a ag:class_Variable ;
    dp:hasVariableName "perEn" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Automatikbetrieb_F1_rPer a ag:class_Variable ;
    dp:hasVariableName "rPer" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_rPer .

ag:Var_FB_Automatikbetrieb_F1_rStart a ag:class_Variable ;
    dp:hasVariableName "rStart" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_rStart .

ag:Var_FB_Automatikbetrieb_F1_rStep1 a ag:class_Variable ;
    dp:hasVariableName "rStep1" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_rStep1 .

ag:Var_FB_Automatikbetrieb_F1_rtStoer a ag:class_Variable ;
    dp:hasVariableName "rtStoer" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_rtStoer .

ag:Var_FB_Automatikbetrieb_F1_tPer a ag:class_Variable ;
    dp:hasVariableName "tPer" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_tPer .

ag:Var_FB_Automatikbetrieb_F1_tSchritt1 a ag:class_Variable ;
    dp:hasVariableName "tSchritt1" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_tSchritt1 .

ag:Var_FB_Automatikbetrieb_F1_tSchritt2 a ag:class_Variable ;
    dp:hasVariableName "tSchritt2" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_Automatikbetrieb_F1_tSchritt2 .

ag:Var_FB_Automatikbetrieb_F1_tpRestart a ag:class_Variable ;
    dp:hasVariableName "tpRestart" ;
    dp:hasVariableType "INT" .

ag:Var_FB_Betriebsarten_A1 a ag:class_Variable ;
    dp:hasVariableName "A1" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_A1 .

ag:Var_FB_Betriebsarten_A2 a ag:class_Variable ;
    dp:hasVariableName "A2" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_A2 .

ag:Var_FB_Betriebsarten_A2_Requested a ag:class_Variable ;
    dp:hasVariableName "A2_Requested" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_A2_Requested .

ag:Var_FB_Betriebsarten_A5 a ag:class_Variable ;
    dp:hasVariableName "A5" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_A5 .

ag:Var_FB_Betriebsarten_A6 a ag:class_Variable ;
    dp:hasVariableName "A6" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_A6 .

ag:Var_FB_Betriebsarten_Alt_abort a ag:class_Variable ;
    dp:hasVariableName "Alt_abort" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Alt_abort .

ag:Var_FB_Betriebsarten_Alt_found a ag:class_Variable ;
    dp:hasVariableName "Alt_found" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Alt_found .

ag:Var_FB_Betriebsarten_Auto_Fertig a ag:class_Variable ;
    dp:hasVariableName "Auto_Fertig" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Auto_Fertig .

ag:Var_FB_Betriebsarten_Auto_Stoerung a ag:class_Variable ;
    dp:hasVariableName "Auto_Stoerung" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Auto_Stoerung .

ag:Var_FB_Betriebsarten_Cycle_ended a ag:class_Variable ;
    dp:hasVariableName "Cycle_ended" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Cycle_ended .

ag:Var_FB_Betriebsarten_D1 a ag:class_Variable ;
    dp:hasVariableName "D1" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_D1 .

ag:Var_FB_Betriebsarten_D2 a ag:class_Variable ;
    dp:hasVariableName "D2" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_D2 .

ag:Var_FB_Betriebsarten_D3 a ag:class_Variable ;
    dp:hasVariableName "D3" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_D3 .

ag:Var_FB_Betriebsarten_D3_Requested a ag:class_Variable ;
    dp:hasVariableName "D3_Requested" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_D3_Requested .

ag:Var_FB_Betriebsarten_F1 a ag:class_Variable ;
    dp:hasVariableName "F1" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_F1 .

ag:Var_FB_Betriebsarten_F4 a ag:class_Variable ;
    dp:hasVariableName "F4" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_F4 .

ag:Var_FB_Betriebsarten_Fehler a ag:class_Variable ;
    dp:hasVariableName "Fehler" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Fehler .

ag:Var_FB_Betriebsarten_Init_reached a ag:class_Variable ;
    dp:hasVariableName "Init_reached" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Init_reached .

ag:Var_FB_Betriebsarten_NotStop a ag:class_Variable ;
    dp:hasVariableName "NotStop" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_NotStop .

ag:Var_FB_Betriebsarten_RS_A1 a ag:class_Variable ;
    dp:hasVariableName "RS_A1" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_A1 .

ag:Var_FB_Betriebsarten_RS_A2 a ag:class_Variable ;
    dp:hasVariableName "RS_A2" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_A2 .

ag:Var_FB_Betriebsarten_RS_A5 a ag:class_Variable ;
    dp:hasVariableName "RS_A5" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_A5 .

ag:Var_FB_Betriebsarten_RS_A6 a ag:class_Variable ;
    dp:hasVariableName "RS_A6" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_A6 .

ag:Var_FB_Betriebsarten_RS_AutomaticOperationMode a ag:class_Variable ;
    dp:hasVariableName "RS_AutomaticOperationMode" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_AutomaticOperationMode .

ag:Var_FB_Betriebsarten_RS_CycleEnded a ag:class_Variable ;
    dp:hasVariableName "RS_CycleEnded" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_CycleEnded .

ag:Var_FB_Betriebsarten_RS_D1 a ag:class_Variable ;
    dp:hasVariableName "RS_D1" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_D1 .

ag:Var_FB_Betriebsarten_RS_D2 a ag:class_Variable ;
    dp:hasVariableName "RS_D2" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_D2 .

ag:Var_FB_Betriebsarten_RS_D3 a ag:class_Variable ;
    dp:hasVariableName "RS_D3" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_D3 .

ag:Var_FB_Betriebsarten_RS_F1 a ag:class_Variable ;
    dp:hasVariableName "RS_F1" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_F1 .

ag:Var_FB_Betriebsarten_RS_InitialDrive a ag:class_Variable ;
    dp:hasVariableName "RS_InitialDrive" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_InitialDrive .

ag:Var_FB_Betriebsarten_RS_InitialState a ag:class_Variable ;
    dp:hasVariableName "RS_InitialState" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_InitialState .

ag:Var_FB_Betriebsarten_RS_ManualOperationMode a ag:class_Variable ;
    dp:hasVariableName "RS_ManualOperationMode" ;
    dp:hasVariableType "RS" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_RS_ManualOperationMode .

ag:Var_FB_Betriebsarten_R_TRIG_Automatic a ag:class_Variable ;
    dp:hasVariableName "R_TRIG_Automatic" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_R_TRIG_Automatic .

ag:Var_FB_Betriebsarten_R_TRIG_CycleEnded a ag:class_Variable ;
    dp:hasVariableName "R_TRIG_CycleEnded" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_R_TRIG_CycleEnded .

ag:Var_FB_Betriebsarten_R_TRIG_Init a ag:class_Variable ;
    dp:hasVariableName "R_TRIG_Init" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_R_TRIG_Init .

ag:Var_FB_Betriebsarten_R_TRIG_InitialDrive a ag:class_Variable ;
    dp:hasVariableName "R_TRIG_InitialDrive" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_R_TRIG_InitialDrive .

ag:Var_FB_Betriebsarten_R_TRIG_Manual a ag:class_Variable ;
    dp:hasVariableName "R_TRIG_Manual" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Betriebsarten_R_TRIG_Manual .

ag:Var_FB_Betriebsarten_Start a ag:class_Variable ;
    dp:hasVariableName "Start" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Start .

ag:Var_FB_Betriebsarten_Start_Init a ag:class_Variable ;
    dp:hasVariableName "Start_Init" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Start_Init .

ag:Var_FB_Betriebsarten_Weiter a ag:class_Variable ;
    dp:hasVariableName "Weiter" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Betriebsarten_Weiter .

ag:Var_FB_Betriebsarten_bFirstScan a ag:class_Variable ;
    dp:hasVariableName "bFirstScan" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Diagnose_D2_Alt_gefunden a ag:class_Variable ;
    dp:hasVariableName "Alt_gefunden" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Diagnose_D2_Alt_gefunden .

ag:Var_FB_Diagnose_D2_Busy a ag:class_Variable ;
    dp:hasVariableName "Busy" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Diagnose_D2_Diagnose_beendet a ag:class_Variable ;
    dp:hasVariableName "Diagnose_beendet" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Diagnose_D2_Diagnose_beendet .

ag:Var_FB_Diagnose_D2_Diagnose_gefordert a ag:class_Variable ;
    dp:hasVariableName "Diagnose_gefordert" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Diagnose_D2_Diagnose_gefordert .

ag:Var_FB_Diagnose_D2_rtAck a ag:class_Variable ;
    dp:hasVariableName "rtAck" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Diagnose_D2_rtAck .

ag:Var_FB_Diagnose_D2_rtD3 a ag:class_Variable ;
    dp:hasVariableName "rtD3" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Diagnose_D2_rtD3 .

ag:Var_FB_Diagnose_D2_rtFinished a ag:class_Variable ;
    dp:hasVariableName "rtFinished" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Diagnose_D2_rtFinished .

ag:Var_FB_Diagnose_D2_rtReq a ag:class_Variable ;
    dp:hasVariableName "rtReq" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_Diagnose_D2_rtReq .

ag:Var_FB_Diagnose_D2_tpPulse a ag:class_Variable ;
    dp:hasVariableName "tpPulse" ;
    dp:hasVariableType "TP" ;
    ag:op_representsFBInstance ag:FBInst_FB_Diagnose_D2_tpPulse .

ag:Var_FB_InitFahrt_A6_A2_A2 a ag:class_Variable ;
    dp:hasVariableName "A2" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_InitFahrt_A6_A2_A2 .

ag:Var_FB_InitFahrt_A6_A2_A6 a ag:class_Variable ;
    dp:hasVariableName "A6" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_InitFahrt_A6_A2_A6 .

ag:Var_FB_InitFahrt_A6_A2_Init_erreicht a ag:class_Variable ;
    dp:hasVariableName "Init_erreicht" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_InitFahrt_A6_A2_Init_erreicht .

ag:Var_FB_InitFahrt_A6_A2_tInit a ag:class_Variable ;
    dp:hasVariableName "tInit" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_InitFahrt_A6_A2_tInit .

ag:Var_FB_Methode1Job_counter a ag:class_Variable ;
    dp:hasVariableName "counter" ;
    dp:hasVariableType "DINT" .

ag:Var_FB_Methode1Job_reached a ag:class_Variable ;
    dp:hasVariableName "reached" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Methode1Job_running a ag:class_Variable ;
    dp:hasVariableName "running" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_Methode1Job_t20s a ag:class_Variable ;
    dp:hasVariableName "t20s" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_Methode1Job_t20s .

ag:Var_FB_Methode1Job_y a ag:class_Variable ;
    dp:hasVariableName "y" ;
    dp:hasVariableType "DINT" .

ag:Var_FB_Notaus_D1_D1 a ag:class_Variable ;
    dp:hasVariableName "D1" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Notaus_D1_D1 .

ag:Var_FB_Notaus_D1_Diagnose_gefordert a ag:class_Variable ;
    dp:hasVariableName "Diagnose_gefordert" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Notaus_D1_Diagnose_gefordert .

ag:Var_FB_Notaus_D1_Notaus_Entriegelt a ag:class_Variable ;
    dp:hasVariableName "Notaus_Entriegelt" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_Notaus_D1_Notaus_Entriegelt .

ag:Var_FB_Notaus_D1_ton5s a ag:class_Variable ;
    dp:hasVariableName "ton5s" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_Notaus_D1_ton5s .

ag:Var_FB_ProduktionMitStoerung_D3_Fertig a ag:class_Variable ;
    dp:hasVariableName "Fertig" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_ProduktionMitStoerung_D3_Fertig .

ag:Var_FB_ProduktionMitStoerung_D3_ProduktionMitStoerung_Starten a ag:class_Variable ;
    dp:hasVariableName "ProduktionMitStoerung_Starten" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_ProduktionMitStoerung_D3_ProduktionMitStoerung_Starten .

ag:Var_FB_ProduktionMitStoerung_D3_RestartPulseLength a ag:class_Variable ;
    dp:hasVariableName "RestartPulseLength" ;
    dp:hasVariableType "INT" .

ag:Var_FB_ProduktionMitStoerung_D3_Schritt3 a ag:class_Variable ;
    dp:hasVariableName "Schritt3" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_ProduktionMitStoerung_D3_Schritt4 a ag:class_Variable ;
    dp:hasVariableName "Schritt4" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_ProduktionMitStoerung_D3_Stoerung_erkannt a ag:class_Variable ;
    dp:hasVariableName "Stoerung_erkannt" ;
    dp:hasVariableType "BOOL" ;
    ag:op_implementsPort ag:Port_FB_ProduktionMitStoerung_D3_Stoerung_erkannt .

ag:Var_FB_ProduktionMitStoerung_D3_Zwischen a ag:class_Variable ;
    dp:hasVariableName "Zwischen" ;
    dp:hasVariableType "string" .

ag:Var_FB_ProduktionMitStoerung_D3_dbg_Stoerung_Manuell a ag:class_Variable ;
    dp:hasVariableName "dbg_Stoerung_Manuell" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_ProduktionMitStoerung_D3_lastSkillIsOne a ag:class_Variable ;
    dp:hasVariableName "lastSkillIsOne" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_ProduktionMitStoerung_D3_pPer a ag:class_Variable ;
    dp:hasVariableName "pPer" ;
    dp:hasVariableType "TP" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_pPer .

ag:Var_FB_ProduktionMitStoerung_D3_perEn a ag:class_Variable ;
    dp:hasVariableName "perEn" ;
    dp:hasVariableType "BOOL" .

ag:Var_FB_ProduktionMitStoerung_D3_rPer a ag:class_Variable ;
    dp:hasVariableName "rPer" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_rPer .

ag:Var_FB_ProduktionMitStoerung_D3_rStart a ag:class_Variable ;
    dp:hasVariableName "rStart" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_rStart .

ag:Var_FB_ProduktionMitStoerung_D3_rStep1 a ag:class_Variable ;
    dp:hasVariableName "rStep1" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_rStep1 .

ag:Var_FB_ProduktionMitStoerung_D3_rtStoer a ag:class_Variable ;
    dp:hasVariableName "rtStoer" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_rtStoer .

ag:Var_FB_ProduktionMitStoerung_D3_tPer a ag:class_Variable ;
    dp:hasVariableName "tPer" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_tPer .

ag:Var_FB_ProduktionMitStoerung_D3_tSchritt3 a ag:class_Variable ;
    dp:hasVariableName "tSchritt3" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_tSchritt3 .

ag:Var_FB_ProduktionMitStoerung_D3_tSchritt4 a ag:class_Variable ;
    dp:hasVariableName "tSchritt4" ;
    dp:hasVariableType "TON" ;
    ag:op_representsFBInstance ag:FBInst_FB_ProduktionMitStoerung_D3_tSchritt4 .

ag:Var_FB_ProduktionMitStoerung_D3_tpRestart a ag:class_Variable ;
    dp:hasVariableName "tpRestart" ;
    dp:hasVariableType "INT" .

ag:Var_FB_ProduktionMitStoerung_D3_z a ag:class_Variable ;
    dp:hasVariableName "z" ;
    dp:hasVariableType "INT" .

ag:Var_MAIN_A2_angefordert a ag:class_Variable ;
    dp:hasVariableName "A2_angefordert" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_D3_angefordert a ag:class_Variable ;
    dp:hasVariableName "D3_angefordert" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_Init_erreicht a ag:class_Variable ;
    dp:hasVariableName "Init_erreicht" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_Init_start a ag:class_Variable ;
    dp:hasVariableName "Init_start" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_Start_eff a ag:class_Variable ;
    dp:hasVariableName "Start_eff" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_Weiter_eff a ag:class_Variable ;
    dp:hasVariableName "Weiter_eff" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_Zyklus_beendet a ag:class_Variable ;
    dp:hasVariableName "Zyklus_beendet" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_alt_abort a ag:class_Variable ;
    dp:hasVariableName "alt_abort" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_alt_found a ag:class_Variable ;
    dp:hasVariableName "alt_found" ;
    dp:hasVariableType "BOOL" .

ag:Var_MAIN_edgeDone a ag:class_Variable ;
    dp:hasVariableName "edgeDone" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_edgeDone .

ag:Var_MAIN_edgeF1 a ag:class_Variable ;
    dp:hasVariableName "edgeF1" ;
    dp:hasVariableType "R_TRIG" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_edgeF1 .

ag:Var_MAIN_fbAuto a ag:class_Variable ;
    dp:hasVariableName "fbAuto" ;
    dp:hasVariableType "FB_Automatikbetrieb_F1" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbAuto .

ag:Var_MAIN_fbBA a ag:class_Variable ;
    dp:hasVariableName "fbBA" ;
    dp:hasVariableType "FB_Betriebsarten" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbBA .

ag:Var_MAIN_fbDiag a ag:class_Variable ;
    dp:hasVariableName "fbDiag" ;
    dp:hasVariableType "FB_Diagnose_D2" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbDiag .

ag:Var_MAIN_fbInit a ag:class_Variable ;
    dp:hasVariableName "fbInit" ;
    dp:hasVariableType "FB_InitFahrt_A6_A2" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbInit .

ag:Var_MAIN_fbJob a ag:class_Variable ;
    dp:hasOPCUADataAccess true ;
    dp:hasOPCUAWriteAccess true ;
    dp:hasVariableName "fbJob" ;
    dp:hasVariableType "FB_Methode1Job" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbJob .

ag:Var_MAIN_fbNot a ag:class_Variable ;
    dp:hasVariableName "fbNot" ;
    dp:hasVariableType "FB_Notaus_D1" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbNot .

ag:Var_MAIN_fbProStoer a ag:class_Variable ;
    dp:hasVariableName "fbProStoer" ;
    dp:hasVariableType "FB_ProduktionMitStoerung_D3" ;
    ag:op_representsFBInstance ag:FBInst_MAIN_fbProStoer .

ag:class_Expression a owl:Class ;
    rdfs:comment "Bbehandelt Ausrücke, wie z.B. AND, OR etc. aus mehreren Variablen oder Werten. Hat zudem immer ExpressionText und einen Verweis auf die erzeugenden Elemente." ;
    rdfs:subClassOf ag:class_SignalSource .

dp:isSpecificLayer a owl:DatatypeProperty ;
    rdfs:comment "Hier wird gespeichert, ob etwas ein spezifisches Layer ist oder nicht. Damit wird insbesondere vom KGManager anhand des Programmcodes festgestellt, ob es sich bei diesem POU um ein GEMMA-Layer oder ein Output-Layer handelt, denn es wird von einer GEMMA-Steuerungsarchitektur ausgegangen, bei der es ein GEMMA-Layer als Steuerungsarchitektur gibt und ein Output-Layer,bei dem die Outputs in Abhängigkeit von den GEMMA-Zuständen ausgegeben werden." ;
    rdfs:domain ag:class_POU ;
    rdfs:range xsd:boolean ;
    rdfs:subPropertyOf dp:hasPOUAttribute .

dp:isUnused a owl:DatatypeProperty .

ag:op_HypothesisConnections a owl:ObjectProperty .

ag:Port_FB_Betriebsarten_Fehler a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Fehler" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Start a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Start" ;
    dp:hasPortType "BOOL" .

ag:Port_FB_Betriebsarten_Weiter a ag:class_Port ;
    dp:hasPortDirection "Input" ;
    dp:hasPortName "Weiter" ;
    dp:hasPortType "BOOL" .

ag:StandardFBType_TP a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "TP" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_TP_ET,
        ag:Port_TP_IN,
        ag:Port_TP_PT,
        ag:Port_TP_Q ;
    rdfs:comment "TP ist ein Impulsbaustein. Eine steigende Flanke an IN startet einen Impuls. Q wird für genau die Dauer PT TRUE, unabhängig davon wie lange IN TRUE bleibt. ET zeigt die verstrichene Impulszeit."@de .

ag:class_PLCProject a owl:Class ;
    rdfs:comment "Diese Klasse beschreibt das gesamte SPS Projekt als oberste Container Entität im Knowledge Graph. Eine Instanz dieser Klasse fasst alle Inhalte zusammen, die aus einem PLCopen XML Export abgeleitet wurden, also Programme, Function Block Typen, globale Variablenlisten und die zugehörigen Verknüpfungen. Das Objekt dient als Einstiegspunkt, um das Modell strukturiert abzufragen und alle Substrukturen eindeutig einem Projekt zuzuordnen. Typischerweise besitzt ein PLCProject Beziehungen zu Programmen und zu globalen Variablenlisten, wodurch nachvollziehbar wird, welche Logik zyklisch ausgeführt wird und welche Variablen projektweit verfügbar sind. In der praktischen Nutzung ist das PLCProject besonders hilfreich, um mehrere Exporte oder Versionen getrennt zu verwalten und Vergleiche zwischen unterschiedlichen Projektständen durchführen zu können. Zusätzlich unterstützt diese Klasse die Nachvollziehbarkeit der Provenienz, da alle abgeleiteten Entitäten eindeutig als Teil eines konkreten Exports interpretiert werden."@de .

ag:class_ParameterAssignment a owl:Class ;
    rdfs:comment "Diese Klasse repräsentiert eine konkrete Parameterzuweisung im Netzwerk und beschreibt damit die Verdrahtung eines Signals von einer Quelle zu einem Zielport. ParameterAssignments sind die zentrale Struktur, um den Datenfluss in einem FBD Modell vollständig abzubilden, da sie definieren, welcher Wert an welchem Eingang anliegt oder welche Variable mit einem Ausgang verbunden ist. Im Knowledge Graph verweist eine ParameterAssignment typischerweise auf eine SignalSource als Ursprung und auf eine PortInstance als Ziel, wodurch die Verbindung eindeutig und instanzbezogen beschrieben wird. Aus PLCopen XML entstehen Parameterzuweisungen aus den Verbindungsinformationen zwischen Block Pins und Variablen oder zwischen mehreren Bausteinen. Diese Klasse ist für Analysen besonders wichtig, weil darüber echte Signalpfade rekonstruiert werden können, beispielsweise vom Startsignal eines Skills über Triggerlogik bis zur Ansteuerung eines Aktors. Außerdem lassen sich darüber automatische Validierungen durchführen, etwa ob alle Pflichtparameter eines Bausteins beschaltet sind oder ob Datentypen konsistent verbunden wurden. Insgesamt ist class_ParameterAssignment die semantische Entsprechung einer Leitung im Schaltplan des FBD und damit eine Schlüsselklasse für jede Graphanalyse."@de .

ag:class_PortInstance a owl:Class ;
    rdfs:comment "Diese Klasse bildet die konkrete Ausprägung eines Ports innerhalb einer spezifischen Function Block Instanz ab und entspricht damit einem realen Pin in einem FBD Netzwerk. Während class_Port nur den abstrakten Parameter eines Typs beschreibt, ist die PortInstance der tatsächliche Anschluss, der im Netzwerk verdrahtet wird und Signale empfängt oder ausgibt. Im Knowledge Graph wird diese Klasse benötigt, weil Signalverbindungen immer an eine konkrete Instanz gebunden sind und nicht nur an den Typ. Eine PortInstance verweist einerseits auf die zugehörige FBInstance und andererseits auf den Port des zugrunde liegenden FBTypes, wodurch eine eindeutige Zuordnung möglich ist. Aus PLCopen XML ergibt sich dieses Konzept aus Block Pins und deren Verbindungen im FBD, die erst im Kontext der Instanz vollständig spezifiziert sind. PortInstanzen sind besonders wichtig für die Rekonstruktion von Signalflüssen, da Parameterzuweisungen genau diese Knoten als Ziel besitzen. Damit ermöglicht class_PortInstance eine vollständige Analyse, welche Variable oder welches Zwischensignal tatsächlich an welchen Bausteinpin angeschlossen ist."@de ;
    rdfs:subClassOf ag:class_SignalSource .

ag:class_Program a owl:Class ;
    rdfs:comment "Diese Klasse repräsentiert ein SPS Programm, das im Normalfall zyklisch von der Runtime ausgeführt wird und daher die oberste Ebene der Steuerungslogik bildet. Programme sind die Haupt Einstiegspunkte für die Ausführung, da sie typische Betriebsartenlogiken, Sequenzen oder Skill Orchestrierungen enthalten. Im Knowledge Graph dient diese Klasse dazu, die Gesamtabläufe sichtbar zu machen und die enthaltenen Aufrufe von Function Blocks als POUCalls explizit zu modellieren. Ein Programm besitzt in der Regel Beziehungen zu den aufgerufenen Bausteinen und deren Parameterzuweisungen, wodurch die Signalflüsse und Startbedingungen nachvollziehbar werden. Aus einem PLCopen XML Export entsteht diese Struktur aus den Program POUs, die häufig als zentrale Knoten für Skill Sets oder Stationslogik fungieren. Für Analysen ist class_Program besonders wichtig, weil hier häufig entschieden wird, welche Subsysteme wann aktiviert werden und welche Ausgänge überhaupt freigegeben werden dürfen. Damit ist die Klasse ideal, um Skill Trigger, Betriebsmodi und globale Abhängigkeiten im Gesamtprojekt zu verstehen."@de ;
    rdfs:subClassOf ag:class_POU .

ag:class_Skill a owl:Class .

ag:class_SkillImplementationHypothesis a owl:Class .

ag:class_GlobalVariableList a owl:Class ;
    rdfs:comment "Diese Klasse beschreibt eine globale Variablenliste als Container, der projektweit zugängliche Variablen zusammenfasst. GlobalVariableLists werden in SPS Projekten verwendet, um gemeinsame Signale, Zustände oder Hardwarezuordnungen zentral zu verwalten und in mehreren Programmen oder Function Blocks nutzbar zu machen. Im Knowledge Graph ermöglicht diese Klasse eine klare Gruppierung der globalen Symbolik und erleichtert Abfragen, die sich auf globale Signale beziehen, etwa auf Safety Signale, Betriebsartenflags oder I O Variablen. Aus PLCopen XML wird eine solche Liste typischerweise aus GVL Bereichen abgeleitet, wobei jede enthaltene Variable separat als class_Variable modelliert wird. Die Klasse unterstützt außerdem die Nachvollziehbarkeit, weil sichtbar wird, welche Variablen tatsächlich global sind und welche nur lokal innerhalb eines Bausteins existieren. Für die Dokumentation ist class_GlobalVariableList hilfreich, um globale Schnittstellen der Anlage zu beschreiben und zentrale Signalgruppen systematisch zu erläutern. Außerdem lassen sich hieraus automatisch Listen für Hardwaremapping oder Schnittstellendokumente erzeugen."@de .

ag:class_POUCall a owl:Class ;
    rdfs:comment "Diese Klasse beschreibt einen konkreten Aufruf einer Program Organisation Unit innerhalb eines Programms oder eines Function Blocks. Ein POUCall macht sichtbar, dass ein bestimmter Baustein nicht nur als Typ existiert, sondern an einer konkreten Stelle tatsächlich verwendet wird. Im Knowledge Graph ist dies essenziell, um Abhängigkeitsstrukturen zu rekonstruieren, also welche Bausteine intern voneinander abhängen und wie tief verschachtelte Logik aufgebaut ist. Ein POUCall kann mit einer FBInstance und deren PortInstanzen verknüpft werden, sodass klar wird, welche konkrete Instanz eines Bausteintyps gemeint ist. Aus PLCopen XML ergibt sich ein POUCall aus einem Bausteinblock im FBD oder aus einem Funktionsaufruf in ST Code, je nach Darstellung. Für die Skill Analyse kann damit nachvollzogen werden, welche Standardbausteine ein Skill verwendet, beispielsweise Trigger, Speicher oder Timer, und welche Unterbausteine die eigentliche Prozesslogik realisieren. Insgesamt macht class_POUCall die Ausführungsstruktur explizit, wodurch sich Skill Ketten, Signalpfade und interne Architektur systematisch untersuchen lassen."@de .

dp:hasPortAttribute a owl:DatatypeProperty .

dp:hasSignalSourceAttribute a owl:DatatypeProperty .

dp:hasVariableAttribute a owl:DatatypeProperty ;
    rdfs:subPropertyOf dp:hasSignalSourceAttribute .

dp:hasHypothesisParams a owl:DatatypeProperty ;
    rdfs:domain ag:class_SkillImplementationHypothesis ;
    rdfs:range xsd:string .

ag:class_SignalSource a owl:Class ;
    rdfs:comment "Diese Klasse stellt eine abstrakte Signalquelle dar und dient als gemeinsamer Oberbegriff für unterschiedliche Ursprünge von Werten im FBD Netzwerk. Eine Signalquelle kann beispielsweise eine Variable sein, eine PortInstance eines Bausteins oder ein konstant definierter Literalwert. Im Knowledge Graph ist diese Abstraktion wichtig, weil Parameterzuweisungen immer nach dem gleichen Muster funktionieren, unabhängig davon, ob der Wert aus einer Variable oder aus einer Bausteinausgabe stammt. Dadurch können Signalflüsse einheitlich modelliert und abgefragt werden, ohne für jede Quelle unterschiedliche Datenstrukturen zu benötigen. Aus PLCopen XML entstehen Signalquellen aus Verdrahtungen, die entweder direkt auf Variablen verweisen oder die Ausgänge anderer Bausteine als Quelle verwenden. Die Klasse unterstützt komplexe Analysen wie Abhängigkeitsgraphen, Datenflussverfolgung oder die Ermittlung von Skill Vorbedingungen, da sich jede Eingangsbelegung auf eine SignalSource zurückführen lässt. Insgesamt sorgt class_SignalSource dafür, dass der Knowledge Graph die semantische Struktur des FBD Netzwerks vollständig und flexibel repräsentieren kann."@de .

dp:hasPOUAttribute a owl:DatatypeProperty ;
    rdfs:domain ag:class_POU .

ag:StandardFBType_TON a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "TON" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_TON_ET,
        ag:Port_TON_IN,
        ag:Port_TON_PT,
        ag:Port_TON_Q ;
    rdfs:comment "TON ist eine Einschaltverzögerung. Wenn IN TRUE wird, startet die Zeitmessung. ET zählt die verstrichene Zeit hoch. Sobald ET die Vorgabezeit PT erreicht und IN weiterhin TRUE ist, wird Q TRUE. Wenn IN FALSE wird, wird der Baustein zurückgesetzt und Q wird FALSE."@de .

ag:class_StandardFBType a owl:Class ;
    rdfs:comment "Diese Klasse beschreibt Standard Function Block Typen, die typischerweise aus der SPS Bibliothek oder dem IEC 61131 3 Standard stammen, zum Beispiel RS Speicher, Triggerbausteine oder Zeitfunktionen. Sie wird eingesetzt, um wiederkehrende Basiskomponenten gesondert zu behandeln und nicht mit den projekt spezifischen Skill Bausteinen zu vermischen. StandardFBTypes dienen häufig als Infrastruktur für Zustandsbildung, Flankenerkennung, Zeitverhalten und Zählfunktionen und sind daher in vielen CustomFBTypes als interne Aufrufe enthalten. Im Knowledge Graph ermöglicht diese Klasse eine robuste Erkennung typischer Muster, etwa dass ein Skill durch einen R_TRIG gestartet wird, durch einen RS gehalten wird und durch Timerbedingungen gestoppt wird. Für die Analyse des Signalflusses sind Standardbausteine besonders relevant, weil sie häufig die eigentlichen Zustandswechsel erzwingen, auch wenn sie fachlich nicht als eigener Skill gelten. Aus PLCopen XML werden sie als POUCalls sichtbar, die innerhalb eines Bausteins auf solche Standardtypen verweisen. Die explizite Modellierung als StandardFBType verbessert außerdem das Filtering in Abfragen, sodass sich beispielsweise reine Skill Graphen ohne Bibliothekslogik erzeugen lassen."@de ;
    rdfs:subClassOf ag:class_FBType .

ag:StandardFBType_RS a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "RS" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_RS_Q1,
        ag:Port_RS_R1,
        ag:Port_RS_S ;
    rdfs:comment "RS ist ein bistabiles Speicherglied mit Reset Priorität. S setzt den gespeicherten Zustand auf TRUE. R1 setzt ihn auf FALSE. Wenn S und R1 gleichzeitig TRUE sind, dominiert Reset und Q1 wird FALSE."@de .

ag:StandardFBType_R_TRIG a ag:class_FBType,
        ag:class_StandardFBType,
        owl:NamedIndividual ;
    dp:hasPOULanguage "ST" ;
    dp:hasPOUName "R_TRIG" ;
    dp:hasPOUType "FunctionBlock" ;
    ag:op_hasPort ag:Port_R_TRIG_CLK,
        ag:Port_R_TRIG_Q ;
    rdfs:comment "R_TRIG erkennt eine steigende Flanke an CLK. Q wird genau für einen Programmscan TRUE, wenn CLK von FALSE auf TRUE wechselt. Damit lassen sich aus einem Signal einzelne Ereignisimpulse ableiten."@de .

ag:class_FBType a owl:Class ;
    rdfs:comment "Diese Klasse beschreibt einen Function Block Typ als wiederverwendbaren Baustein mit fest definierter Schnittstelle und interner Logik. Ein FBType enthält typischerweise Eingänge, Ausgänge und interne Variablen sowie entweder ST Code oder eine aus dem FBD Netzwerk rekonstruierte Darstellung. Im Knowledge Graph wird der Baustein als Typ modelliert, damit einzelne Instanzen desselben Bausteins konsistent beschrieben und analysiert werden können. Die Ports eines FBType werden über class_Port repräsentiert und definieren Richtung und Datentyp der jeweiligen Parameter, wodurch eine saubere Typanalyse der Verdrahtung möglich ist. Darüber hinaus kann ein FBType selbst weitere POUs aufrufen, etwa Standardbausteine wie Trigger oder Timer, was über POUCalls nachvollzogen wird. Die Klasse ist zentral, um das Projekt modular zu verstehen, da sie die fachliche Logik kapselt, zum Beispiel Bewegungssteuerungen, Sensor Auswertungen oder Betriebsartenautomaten. Bei der Analyse von Skills ist class_FBType besonders wertvoll, weil sie die wiederkehrenden Muster einer Skill Implementierung sichtbar macht, etwa Start Trigger, Zustandsautomaten, Reset Mechanismen und Sicherheitsabfragen."@de ;
    rdfs:subClassOf ag:class_POU .

ag:class_POU a owl:Class ;
    rdfs:comment "Diese Klasse bildet das allgemeine Konzept einer Program Organisation Unit ab und dient als Oberbegriff für Programme und Function Blocks im Sinne der IEC 61131 3 Struktur. Sie wird im Knowledge Graph verwendet, um eine gemeinsame Abstraktion für alle ausführbaren oder wiederverwendbaren Bausteine bereitzustellen, unabhängig davon, ob sie zyklisch laufen oder innerhalb anderer Bausteine aufgerufen werden. Dadurch lassen sich Analyseoperationen vereinheitlichen, zum Beispiel die Suche nach Aufrufbeziehungen, der Vergleich von Schnittstellen oder das Auffinden von internen Abhängigkeiten. In einem PLCopen XML Export entsprechen POUs typischerweise den Elementen, die eine Bausteindefinition samt Interface und Code oder Netzwerkstruktur enthalten. In diesem Modell ist class_POU vor allem eine semantische Klammer, die eine saubere Spezialisierung zu class_Program und class_FBType ermöglicht. In praktischen Abfragen wird diese Klasse häufig indirekt genutzt, um alle ausführbaren Einheiten zusammenzufassen und anschließend nach Typ oder Sprache zu filtern."@de .

ag:class_FBInstance a owl:Class ;
    rdfs:comment "Diese Klasse beschreibt eine konkrete Instanz eines Function Block Typs innerhalb eines Programms oder eines anderen Bausteins. Während class_FBType den Bauplan liefert, stellt class_FBInstance das tatsächliche Objekt dar, das in einem Netzwerk verwendet wird und dessen interne Zustände während der Laufzeit existieren. Im Knowledge Graph ist diese Klasse entscheidend, um die echte Struktur des FBD Netzwerks abzubilden, weil ein Baustein mehrfach instanziiert werden kann, jeweils mit eigenen Parametern, eigenen Variablenzuordnungen und eigenem Zustand. Eine FBInstance ist über Beziehungen einem FBType zugeordnet und besitzt PortInstanzen, die die konkreten Pins dieser Instanz darstellen. Damit lassen sich Verdrahtungen und Signalwege nicht nur abstrakt, sondern real und vollständig nachvollziehen. In PLCopen XML entspricht dies dem Auftreten eines Baustein Blocks im Netzwerk, also einer konkreten Verwendung innerhalb des FBD. Für Skill Analysen ist class_FBInstance besonders wichtig, weil hier ersichtlich wird, welche spezifischen Sensoren, Aktoren oder Parameter an einen Skill angeschlossen sind und wie die Logik in einer konkreten Station konfiguriert wurde."@de .

ag:class_Port a owl:Class ;
    rdfs:comment "Diese Klasse repräsentiert einen Port als Bestandteil eines Function Block Typs und definiert damit die formale Schnittstelle eines Bausteins. Ein Port beschreibt, ob ein Parameter ein Eingang oder Ausgang ist und welchen Datentyp er besitzt, etwa BOOL, INT, TIME oder andere PLC Typen. Im Knowledge Graph ist diese Struktur notwendig, um Verdrahtungen formal korrekt abzubilden und später automatisiert zu prüfen, ob Signale kompatibel verbunden wurden. Ports existieren zunächst nur auf der Typ Ebene und werden erst durch PortInstanzen innerhalb einer konkreten FBInstance tatsächlich genutzt. Aus PLCopen XML lässt sich ein Port aus den Variablendeklarationen eines POUs ableiten oder aus der Pinbeschreibung eines Bausteinblocks rekonstruieren. Die Klasse unterstützt außerdem semantische Abfragen, zum Beispiel die Suche nach allen Skills, die einen bestimmten Eingang besitzen oder die Ausgabe eines bestimmten Statussignals bereitstellen. Insgesamt dient class_Port als zentraler Baustein, um das Schnittstellen Design der Steuerung explizit zu modellieren und als Grundlage für Skill Kopplung und Parametervalidierung zu verwenden."@de .

ag:class_Variable a owl:Class ;
    rdfs:comment "Diese Klasse repräsentiert Variablen im SPS Projekt, unabhängig davon, ob es sich um globale Variablen, lokale Variablen, Ein und Ausgänge oder Instanzvariablen handelt. Variablen sind zentrale Träger von Zuständen und Signalen, da über sie Sensorwerte gelesen, Aktoren angesteuert und interne Zwischenergebnisse gespeichert werden. Im Knowledge Graph kann eine Variable zusätzlich Hardwareinformationen enthalten, beispielsweise eine physikalische Adresse oder eine Zuordnung zu einem IO Channel, wodurch die Verbindung zwischen Logik und Feldhardware sichtbar wird. Variablen können außerdem genutzt werden, um Function Block Instanzen abzubilden, da viele PLC Systeme Instanzen über benannte Variablen in der Symbolik repräsentieren. Aus PLCopen XML stammen Variablen aus den Deklarationsbereichen eines POUs, aus globalen Variablenlisten oder aus I O Mappings. Für Skill Analysen ist class_Variable besonders wertvoll, weil darüber erkennbar wird, welche realen Sensoren und Aktoren ein Skill verwendet und welche Parameter in die Skill Aufrufe einfließen. Zusätzlich erlaubt diese Klasse Konsistenzprüfungen, etwa ob eine Variable als BOOL modelliert ist und dennoch mit einem numerischen Port verbunden wurde."@de ;
    rdfs:subClassOf ag:class_SignalSource .

