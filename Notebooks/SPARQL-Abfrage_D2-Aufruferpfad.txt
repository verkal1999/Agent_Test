Codex Chat Traceauswahl letzte Notebook-Zelle "Ok, der Algorithmus läuft wieder falsch. Er müsste jetzt eigentlich wie folgt vorgehen: Erstmal muss er den Eintrag finden, wo OPCUA.lastExecutedSkill auf 'TestSkill3' gesetzt wird und das passiert in "OPCUA.lastExecutedSkill := 'TestSkill3';" Jetzt muss geprüft werden, was die Bedingung dafür ist. Dann soll dieses IF gefunden werden "IF lastSkillIsOne THEN
        OPCUA.lastExecutedSkill := 'TestSkill3';
    ELSE
        OPCUA.lastExecutedSkill := 'TestSkill1';
    END_IF" Dann ist klar, lastSkillIsOne muss := TRUE sein. Dann wurd geschaut, wo es gesetzt wird und es wird  lastSkillIsOne := NOT lastSkillIsOne;" gefunden. Daraus  muss jetzt klar sein, dass lastSkillIsOne = FALSE sein musste, weil es hier invertiert wird. Dann wird die Bedingung dafür gesucht und man findet  "IF rStep1.Q THEN 
    lastSkillIsOne := NOT lastSkillIsOne;
    IF lastSkillIsOne THEN
        OPCUA.lastExecutedSkill := 'TestSkill3';
    ELSE
        OPCUA.lastExecutedSkill := 'TestSkill1';
    END_IF
END_IF". Dann wird daraus herausgefunden, dass rStep1.Q = TRUE sein muss. Anhand des Punktes identifiziert man das dann aus dem KG mit "

PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX ag: <http://www.semanticweb.org/AgentProgramParams/>
SELECT *
WHERE {
?pou a ag:class_CustomFBType;
 ag:dp_isGEMMAStateMachine "true"^^xsd:boolean;
ag:op_hasPort ?port.
#Port finden
?port ag:dp_hasPortName "Auto_Stoerung"^^xsd:string;
#PortDirection ansehen
 ag:dp_hasPortDirection ?port_dir.
#Wenn ?port_die input^^xsd:string ist, dann muss es einen Aufruf gegeben haben.
?assignment ag:op_assignsToPort ?port.
#Jetzt die Instanz suchen, die verbunden wurde
?assignment ag:op_assignsFrom ?port_instance_caller.
?port_instance_caller ag:op_instantiatesPort ?callerPort.
#Jetzt ist klar, mit welchem Wert von welchem Port dieser Port belegt wurde. Jetzt hole ich die POU-URI und den Namen des Output-Ports im Aufrufer, checke aber vorher, ob es ein Output-Port ist. Wenn es ein Input-Port ist, soll mit derselben Logik vorgegangen werden, um den konkreten Aufrufer dafür zu finden, bis auf den Output-port gestoßen wird.
?callerPort ag:dp_hasPortDirection ?caller_dir;
# Ist Output, also wurde der Aufrufer gefunden.
 ag:dp_hasPortName ?callerPortName.
#Jetzt ist klar, woher genau der Aufruf dieser Variable gestammt hat.
?callerPOU ag:op_hasPort ?callerPort;
	ag:dp_hasPOUCode ?callerCode.
}

PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX ag: <http://www.semanticweb.org/AgentProgramParams/>
SELECT *
WHERE {
#Hier den Namen der aufrufenden Instanz dynamisch einfügen und auf die Instanz kommen, die damit verwendet wird
?instVar ag:dp_hasVariableName "fbBA"^^xsd:string;
 ag:op_representsFBInstance ?inst.
#Dann von der Instanz den Typ bzw. den FB ermitteln, den die Instanz instanziiert
?inst ag:op_isInstanceOfFBType ?searchFB.
#Und jetzt hier die Sprache ermitteln, wodurch später der richtige Algorithmus verwendet werden kann, um Assignments zu prüfen. Hier kann bisher FBD oder ST herauskommen.
?searchFB ag:dp_hasPOULanguage ?lang.
#Der Name hier würde der Name des FB_Type sein, der beim Aufruf der Methode eingefügt wird.
#<http://www.semanticweb.org/AgentProgramParams/FBType_FB_Automatikbetrieb_F1> ?property ?searchObj.
#Der String ist der Name der gesuchten Instanz
#?searchObj ?property2 "Automatikbetrieb_Starten"^^xsd:string.
#Damit suche in die FB-Instanz, auf die von dieser Variable gezeigt wird und was diese FB-Instanz genau ist.
#?searchObj ag:op_representsFBInstance ?fbinst.
#Hier kommt heraus FBInst_FB_Automatikbetrieb_F1_pPer
#?fbinst ag:op_isInstanceOfFBType ?fbinst_type.
#?fbinst_type rdfs:comment ?descr.
}

Erstmal aus "IF rStep1.Q THEN
    lastSkillIsOne := NOT lastSkillIsOne;
    IF lastSkillIsOne THEN
        OPCUA.lastExecutedSkill := 'TestSkill3';
    ELSE
        OPCUA.lastExecutedSkill := 'TestSkill1';
    END_IF
END_IF":
OPCUA.lastExecutedSkill := 'TestSkill3'; wird gesetzt bei lastSkillIsOne, der auf NOT lastSkillIsOne gesetzt wird, also einfach invertiert wird. Trotzdem muss er auf TRUE sein nach dem Invertieren. Damit das aber Funktioniert, muss rStep1.Q = TRUE sein. Wenn ich dann aus nach rStep1 suche, finde ich "rStep1(CLK := Schritt1);"